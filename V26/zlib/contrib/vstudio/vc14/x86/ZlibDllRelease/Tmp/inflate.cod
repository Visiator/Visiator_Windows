; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	c:\prj\visiator_windows\v26\zlib\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateCodesUsed@4
PUBLIC	_inflateMark@4
PUBLIC	_inflateValidate@8
PUBLIC	_inflateUndermine@8
PUBLIC	_inflateCopy@8
PUBLIC	_inflateSyncPoint@4
PUBLIC	_inflateSync@4
PUBLIC	_inflateGetHeader@8
PUBLIC	_inflateSetDictionary@12
PUBLIC	_inflateGetDictionary@12
PUBLIC	_inflatePrime@12
PUBLIC	_inflateInit_@12
PUBLIC	_inflateReset2@8
PUBLIC	_inflateResetKeep@4
PUBLIC	_inflateEnd@4
PUBLIC	_inflate@8
PUBLIC	_inflateInit2_@16
PUBLIC	_inflateReset@4
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateRes
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 155  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateRes:

; 150  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 151  :     state->wsize = 0;
; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;
; 154  :     return inflateResetKeep(strm);

  0001b	89 4d 08	 mov	 DWORD PTR _strm$[ebp], ecx
  0001e	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  00025	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
  0002c	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 155  : }

  00033	5d		 pop	 ebp

; 151  :     state->wsize = 0;
; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;
; 154  :     return inflateResetKeep(strm);

  00034	e9 00 00 00 00	 jmp	 _inflateResetKeep@4
_inflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 201  :     int ret;
; 202  :     struct inflate_state FAR *state;
; 203  : 
; 204  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 ac 00 00
	00		 je	 $LN3@inflateIni
  00012	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00015	0f 85 a3 00 00
	00		 jne	 $LN3@inflateIni
  0001b	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001f	0f 85 99 00 00
	00		 jne	 $LN3@inflateIni

; 207  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00025	85 f6		 test	 esi, esi
  00027	75 08		 jne	 SHORT $LN4@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 237  : }

  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
$LN4@inflateIni:

; 208  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 209  :     if (strm->zalloc == (alloc_func)0) {

  00031	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00034	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003b	85 c0		 test	 eax, eax
  0003d	75 13		 jne	 SHORT $LN10@inflateIni

; 210  : #ifdef Z_SOLO
; 211  :         return Z_STREAM_ERROR;
; 212  : #else
; 213  :         strm->zalloc = zcalloc;
; 214  :         strm->opaque = (voidpf)0;

  0003f	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00042	33 c9		 xor	 ecx, ecx
  00044	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET _zcalloc
  00050	eb 03		 jmp	 SHORT $LN5@inflateIni
$LN10@inflateIni:
  00052	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
$LN5@inflateIni:

; 215  : #endif
; 216  :     }
; 217  :     if (strm->zfree == (free_func)0)

  00055	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00059	75 07		 jne	 SHORT $LN6@inflateIni

; 218  : #ifdef Z_SOLO
; 219  :         return Z_STREAM_ERROR;
; 220  : #else
; 221  :         strm->zfree = zcfree;

  0005b	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN6@inflateIni:
  00062	57		 push	 edi

; 222  : #endif
; 223  :     state = (struct inflate_state FAR *)

  00063	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00068	6a 01		 push	 1
  0006a	51		 push	 ecx
  0006b	ff d0		 call	 eax
  0006d	8b f8		 mov	 edi, eax
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 224  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 225  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00072	85 ff		 test	 edi, edi
  00074	75 09		 jne	 SHORT $LN7@inflateIni
  00076	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi

; 237  : }

  0007b	5d		 pop	 ebp
  0007c	c2 10 00	 ret	 16			; 00000010H
$LN7@inflateIni:
  0007f	53		 push	 ebx

; 226  :     Tracev((stderr, "inflate: allocated\n"));
; 227  :     strm->state = (struct internal_state FAR *)state;
; 228  :     state->strm = strm;
; 229  :     state->window = Z_NULL;
; 230  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 231  :     ret = inflateReset2(strm, windowBits);

  00080	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  00083	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00086	56		 push	 esi
  00087	89 37		 mov	 DWORD PTR [edi], esi
  00089	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
  00090	c7 47 04 34 3f
	00 00		 mov	 DWORD PTR [edi+4], 16180 ; 00003f34H
  00097	e8 00 00 00 00	 call	 _inflateReset2@8
  0009c	8b d8		 mov	 ebx, eax

; 232  :     if (ret != Z_OK) {

  0009e	85 db		 test	 ebx, ebx
  000a0	74 13		 je	 SHORT $LN8@inflateIni

; 233  :         ZFREE(strm, state);

  000a2	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  000a5	57		 push	 edi
  000a6	ff 76 28	 push	 DWORD PTR [esi+40]
  000a9	ff d1		 call	 ecx
  000ab	83 c4 08	 add	 esp, 8

; 234  :         strm->state = Z_NULL;

  000ae	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN8@inflateIni:

; 235  :     }
; 236  :     return ret;

  000b5	8b c3		 mov	 eax, ebx
  000b7	5b		 pop	 ebx
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi

; 237  : }

  000ba	5d		 pop	 ebp
  000bb	c2 10 00	 ret	 16			; 00000010H
$LN3@inflateIni:

; 205  :         stream_size != (int)(sizeof(z_stream)))
; 206  :         return Z_VERSION_ERROR;

  000be	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  000c3	5e		 pop	 esi

; 237  : }

  000c4	5d		 pop	 ebp
  000c5	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflate@8
_TEXT	SEGMENT
tv5566 = -64						; size = 4
tv5514 = -64						; size = 4
tv5504 = -64						; size = 4
tv5496 = -64						; size = 4
$T1 = -60						; size = 4
$T2 = -60						; size = 4
$T3 = -60						; size = 4
$T4 = -60						; size = 4
_copy$7$ = -60						; size = 4
_copy$3$ = -60						; size = 4
_copy$2$ = -60						; size = 4
_copy$1$ = -60						; size = 4
tv5684 = -60						; size = 4
tv5671 = -60						; size = 4
tv5661 = -60						; size = 4
tv5611 = -60						; size = 4
tv5596 = -60						; size = 4
tv5595 = -60						; size = 4
tv5561 = -60						; size = 4
tv5553 = -60						; size = 4
tv5534 = -60						; size = 4
tv5519 = -60						; size = 4
tv5515 = -60						; size = 4
tv5246 = -60						; size = 4
_len$1$ = -60						; size = 4
_in$1$ = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -52						; size = 4
$T7 = -52						; size = 4
$T8 = -52						; size = 4
$T9 = -52						; size = 4
$T10 = -52						; size = 4
_from$1$ = -52						; size = 4
_len$2$ = -52						; size = 4
tv5560 = -52						; size = 4
tv5522 = -52						; size = 4
tv5521 = -52						; size = 4
_last$ = -52						; size = 4
_ret$1$ = -48						; size = 4
$T11 = -44						; size = 4
$T12 = -44						; size = 4
$T13 = -44						; size = 4
_copy$4$ = -44						; size = 4
tv5680 = -44						; size = 4
tv5665 = -44						; size = 4
tv5559 = -44						; size = 4
_out$1$ = -40						; size = 4
_put$1$ = -36						; size = 4
_left$1$ = -32						; size = 4
_hbuf$ = -28						; size = 4
$T14 = -24						; size = 4
_bits$1$ = -24						; size = 4
tv5524 = -20						; size = 4
_next$1$ = -20						; size = 4
_have$1$ = -16						; size = 4
_state$1$ = -12						; size = 4
_hold$1$ = -8						; size = 4
tv5664 = -1						; size = 1
tv5663 = -1						; size = 1
tv5482 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx

; 626  :     struct inflate_state FAR *state;
; 627  :     z_const unsigned char FAR *next;    /* next input */
; 628  :     unsigned char FAR *put;     /* next output */
; 629  :     unsigned have, left;        /* available input and output */
; 630  :     unsigned long hold;         /* bit buffer */
; 631  :     unsigned bits;              /* bits in bit buffer */
; 632  :     unsigned in, out;           /* save starting available input and output */
; 633  :     unsigned copy;              /* number of stored or match bytes to copy */
; 634  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 635  :     code here;                  /* current decoding table entry */
; 636  :     code last;                  /* parent table entry */
; 637  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 638  :     int ret;                    /* return code */
; 639  : #ifdef GUNZIP
; 640  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 641  : #endif
; 642  :     static const unsigned short order[19] = /* permutation of code lengths */
; 643  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 644  : 
; 645  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  0000a	8b cb		 mov	 ecx, ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 _inflateStateCheck
  00013	85 c0		 test	 eax, eax
  00015	0f 85 07 11 00
	00		 jne	 $LN333@inflate
  0001b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0001e	89 45 dc	 mov	 DWORD PTR _put$1$[ebp], eax
  00021	85 c0		 test	 eax, eax
  00023	0f 84 f9 10 00
	00		 je	 $LN333@inflate
  00029	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0002b	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0002e	85 ff		 test	 edi, edi
  00030	75 09		 jne	 SHORT $LN749@inflate
  00032	39 7b 04	 cmp	 DWORD PTR [ebx+4], edi
  00035	0f 85 e7 10 00
	00		 jne	 $LN333@inflate
$LN749@inflate:

; 646  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 647  :         return Z_STREAM_ERROR;
; 648  : 
; 649  :     state = (struct inflate_state FAR *)strm->state;

  0003b	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  0003e	89 4d f4	 mov	 DWORD PTR _state$1$[ebp], ecx

; 650  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00041	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00044	89 45 d4	 mov	 DWORD PTR $T13[ebp], eax
  00047	3d 3f 3f 00 00	 cmp	 eax, 16191		; 00003f3fH
  0004c	75 1a		 jne	 SHORT $LN4@inflate
  0004e	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H
  00055	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00058	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0005a	89 45 dc	 mov	 DWORD PTR _put$1$[ebp], eax
  0005d	b8 40 3f 00 00	 mov	 eax, 16192		; 00003f40H
  00062	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00065	89 45 d4	 mov	 DWORD PTR $T13[ebp], eax
$LN4@inflate:

; 651  :     LOAD();

  00068	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  0006b	05 cc c0 ff ff	 add	 eax, -16180		; ffffc0ccH
  00070	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00073	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00076	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00079	89 7d e0	 mov	 DWORD PTR _left$1$[ebp], edi
  0007c	89 7d d8	 mov	 DWORD PTR _out$1$[ebp], edi
  0007f	33 ff		 xor	 edi, edi
  00081	89 7d d0	 mov	 DWORD PTR _ret$1$[ebp], edi
  00084	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00087	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0008a	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0008d	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00090	89 5d c8	 mov	 DWORD PTR _in$1$[ebp], ebx
  00093	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00096	0f 87 86 10 00
	00		 ja	 $LN333@inflate
  0009c	0f 1f 40 00	 npad	 4
$LL5@inflate:
  000a0	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN979@inflate[eax*4]
$LN335@inflate:

; 657  :         case HEAD:
; 658  :             if (state->wrap == 0) {

  000a7	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000aa	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
  000ad	85 c0		 test	 eax, eax
  000af	75 0c		 jne	 SHORT $LN12@inflate

; 659  :                 state->mode = TYPEDO;

  000b1	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H

; 660  :                 break;

  000b8	e9 51 10 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  000bd	83 fe 10	 cmp	 esi, 16			; 00000010H
  000c0	73 2d		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000c2	85 db		 test	 ebx, ebx
  000c4	0f 84 38 15 00
	00		 je	 $LN930@inflate
  000ca	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000cd	8b ce		 mov	 ecx, esi
  000cf	d3 e0		 shl	 eax, cl
  000d1	83 c6 08	 add	 esi, 8
  000d4	4b		 dec	 ebx
  000d5	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  000d8	03 d0		 add	 edx, eax
  000da	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  000dd	47		 inc	 edi
  000de	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  000e1	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  000e4	83 fe 10	 cmp	 esi, 16			; 00000010H
  000e7	72 d9		 jb	 SHORT $LL13@inflate
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000ec	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
$LN10@inflate:

; 663  : #ifdef GUNZIP
; 664  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000ef	a8 02		 test	 al, 2
  000f1	74 56		 je	 SHORT $LN338@inflate
  000f3	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000f9	75 4e		 jne	 SHORT $LN338@inflate

; 665  :                 if (state->wbits == 0)

  000fb	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  000ff	75 07		 jne	 SHORT $LN339@inflate

; 666  :                     state->wbits = 15;

  00101	c7 41 28 0f 00
	00 00		 mov	 DWORD PTR [ecx+40], 15	; 0000000fH
$LN339@inflate:

; 667  :                 state->check = crc32(0L, Z_NULL, 0);

  00108	6a 00		 push	 0
  0010a	6a 00		 push	 0
  0010c	6a 00		 push	 0
  0010e	e8 00 00 00 00	 call	 _crc32@12
  00113	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 668  :                 CRC2(state->check, hold);

  00116	6a 02		 push	 2
  00118	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0011b	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  0011e	50		 push	 eax
  0011f	66 c7 45 e4 1f
	8b		 mov	 WORD PTR _hbuf$[ebp], 35615 ; 00008b1fH
  00125	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00128	e8 00 00 00 00	 call	 _crc32@12
  0012d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 669  :                 INITBITS();

  00130	33 d2		 xor	 edx, edx
  00132	33 f6		 xor	 esi, esi
  00134	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00137	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0013a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 670  :                 state->mode = FLAGS;

  0013d	c7 41 04 35 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16181 ; 00003f35H

; 671  :                 break;

  00144	e9 c5 0f 00 00	 jmp	 $LN8@inflate
$LN338@inflate:

; 672  :             }
; 673  :             state->flags = 0;           /* expect zlib header */
; 674  :             if (state->head != Z_NULL)

  00149	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0014c	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00153	85 c0		 test	 eax, eax
  00155	74 07		 je	 SHORT $LN938@inflate

; 675  :                 state->head->done = -1;

  00157	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN938@inflate:

; 676  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  0015e	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00161	a8 01		 test	 al, 1
  00163	0f 84 d6 00 00
	00		 je	 $LN342@inflate
  00169	0f b6 ca	 movzx	 ecx, dl
  0016c	8b c2		 mov	 eax, edx
  0016e	c1 e1 08	 shl	 ecx, 8
  00171	33 d2		 xor	 edx, edx
  00173	c1 e8 08	 shr	 eax, 8
  00176	03 c1		 add	 eax, ecx
  00178	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0017d	f7 f1		 div	 ecx
  0017f	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00182	85 d2		 test	 edx, edx
  00184	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00187	0f 85 b2 00 00
	00		 jne	 $LN342@inflate

; 684  :             }
; 685  :             if (BITS(4) != Z_DEFLATED) {

  0018d	8b c2		 mov	 eax, edx
  0018f	24 0f		 and	 al, 15			; 0000000fH
  00191	3c 08		 cmp	 al, 8
  00193	74 16		 je	 SHORT $LN26@inflate
$LN976@inflate:

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  00195	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00198	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  0019f	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  001a6	e9 63 0f 00 00	 jmp	 $LN8@inflate
$LN26@inflate:

; 686  :                 strm->msg = (char *)"unknown compression method";
; 687  :                 state->mode = BAD;
; 688  :                 break;
; 689  :             }
; 690  :             DROPBITS(4);
; 691  :             len = BITS(4) + 8;
; 692  :             if (state->wbits == 0)

  001ab	8b 79 28	 mov	 edi, DWORD PTR [ecx+40]
  001ae	83 ee 04	 sub	 esi, 4
  001b1	c1 ea 04	 shr	 edx, 4
  001b4	8b c2		 mov	 eax, edx
  001b6	89 7d cc	 mov	 DWORD PTR $T8[ebp], edi
  001b9	83 e0 0f	 and	 eax, 15			; 0000000fH
  001bc	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  001bf	83 c0 08	 add	 eax, 8
  001c2	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  001c5	85 ff		 test	 edi, edi
  001c7	89 45 c4	 mov	 DWORD PTR _len$1$[ebp], eax
  001ca	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  001cd	75 06		 jne	 SHORT $LN344@inflate

; 693  :                 state->wbits = len;

  001cf	89 41 28	 mov	 DWORD PTR [ecx+40], eax
  001d2	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
$LN344@inflate:

; 694  :             if (len > 15 || len > state->wbits) {

  001d5	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001d8	77 4f		 ja	 SHORT $LN346@inflate
  001da	3b 45 cc	 cmp	 eax, DWORD PTR $T8[ebp]
  001dd	77 4a		 ja	 SHORT $LN346@inflate

; 698  :             }
; 699  :             state->dmax = 1U << len;

  001df	8b 4d c4	 mov	 ecx, DWORD PTR _len$1$[ebp]
  001e2	b8 01 00 00 00	 mov	 eax, 1
  001e7	d3 e0		 shl	 eax, cl
  001e9	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 700  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 701  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001ec	6a 00		 push	 0
  001ee	6a 00		 push	 0
  001f0	6a 00		 push	 0
  001f2	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001f5	e8 00 00 00 00	 call	 _adler32@12
  001fa	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001fd	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00200	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00203	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 702  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00206	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00209	c1 ea 08	 shr	 edx, 8
  0020c	f7 d2		 not	 edx
  0020e	83 e2 02	 and	 edx, 2
  00211	81 ca 3d 3f 00
	00		 or	 edx, 16189		; 00003f3dH
  00217	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 703  :             INITBITS();

  0021a	33 d2		 xor	 edx, edx
  0021c	33 f6		 xor	 esi, esi
  0021e	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00221	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 704  :             break;

  00224	e9 e5 0e 00 00	 jmp	 $LN8@inflate
$LN346@inflate:

; 695  :                 strm->msg = (char *)"invalid window size";

  00229	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0022c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size@

; 696  :                 state->mode = BAD;

  00233	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 697  :                 break;

  0023a	e9 cf 0e 00 00	 jmp	 $LN8@inflate
$LN342@inflate:

; 677  : #else
; 678  :             if (
; 679  : #endif
; 680  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 681  :                 strm->msg = (char *)"incorrect header check";

  0023f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00242	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@

; 682  :                 state->mode = BAD;

  00249	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 683  :                 break;

  00250	e9 b9 0e 00 00	 jmp	 $LN8@inflate
$LN32@inflate:

; 705  : #ifdef GUNZIP
; 706  :         case FLAGS:
; 707  :             NEEDBITS(16);

  00255	83 fe 10	 cmp	 esi, 16			; 00000010H
  00258	73 30		 jae	 SHORT $LN30@inflate
  0025a	66 0f 1f 44 00
	00		 npad	 6
$LL33@inflate:
  00260	85 db		 test	 ebx, ebx
  00262	0f 84 9a 13 00
	00		 je	 $LN930@inflate
  00268	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0026b	8b ce		 mov	 ecx, esi
  0026d	d3 e0		 shl	 eax, cl
  0026f	83 c6 08	 add	 esi, 8
  00272	4b		 dec	 ebx
  00273	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00276	03 d0		 add	 edx, eax
  00278	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0027b	47		 inc	 edi
  0027c	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0027f	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00282	83 fe 10	 cmp	 esi, 16			; 00000010H
  00285	72 d9		 jb	 SHORT $LL33@inflate
  00287	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN30@inflate:

; 708  :             state->flags = (int)(hold);

  0028a	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 709  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  0028d	80 fa 08	 cmp	 dl, 8
  00290	0f 85 ff fe ff
	ff		 jne	 $LN976@inflate

; 710  :                 strm->msg = (char *)"unknown compression method";
; 711  :                 state->mode = BAD;
; 712  :                 break;
; 713  :             }
; 714  :             if (state->flags & 0xe000) {

  00296	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  0029c	74 16		 je	 SHORT $LN350@inflate

; 715  :                 strm->msg = (char *)"unknown header flags set";

  0029e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  002a1	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
  002a8	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  002af	e9 5a 0e 00 00	 jmp	 $LN8@inflate
$LN350@inflate:

; 716  :                 state->mode = BAD;
; 717  :                 break;
; 718  :             }
; 719  :             if (state->head != Z_NULL)

  002b4	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  002b7	8b c2		 mov	 eax, edx
  002b9	c1 e8 08	 shr	 eax, 8
  002bc	89 55 cc	 mov	 DWORD PTR $T7[ebp], edx
  002bf	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax
  002c2	85 f6		 test	 esi, esi
  002c4	74 0e		 je	 SHORT $LN750@inflate

; 720  :                 state->head->text = (int)((hold >> 8) & 1);

  002c6	83 e0 01	 and	 eax, 1
  002c9	89 06		 mov	 DWORD PTR [esi], eax
  002cb	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  002ce	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax
  002d1	8b 45 c4	 mov	 eax, DWORD PTR $T4[ebp]
$LN750@inflate:

; 721  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002d4	f7 45 cc 00 02
	00 00		 test	 DWORD PTR $T7[ebp], 512	; 00000200H
  002db	74 20		 je	 SHORT $LN39@inflate
  002dd	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  002e1	74 1a		 je	 SHORT $LN39@inflate

; 722  :                 CRC2(state->check, hold);

  002e3	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  002e6	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  002e9	6a 02		 push	 2
  002eb	50		 push	 eax
  002ec	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  002ef	ff 71 1c	 push	 DWORD PTR [ecx+28]
  002f2	e8 00 00 00 00	 call	 _crc32@12
  002f7	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  002fa	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN39@inflate:

; 723  :             INITBITS();

  002fd	33 d2		 xor	 edx, edx

; 724  :             state->mode = TIME;

  002ff	c7 41 04 36 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16182 ; 00003f36H
  00306	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00309	33 f6		 xor	 esi, esi

; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  0030b	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  0030d	83 fe 20	 cmp	 esi, 32			; 00000020H
  00310	73 27		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  00312	85 db		 test	 ebx, ebx
  00314	0f 84 e8 12 00
	00		 je	 $LN930@inflate
  0031a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0031d	8b ce		 mov	 ecx, esi
  0031f	d3 e0		 shl	 eax, cl
  00321	4b		 dec	 ebx
  00322	03 d0		 add	 edx, eax
  00324	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00327	47		 inc	 edi
  00328	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0032b	83 c6 08	 add	 esi, 8
  0032e	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00331	83 fe 20	 cmp	 esi, 32			; 00000020H
  00334	72 dc		 jb	 SHORT $LL47@inflate
  00336	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN44@inflate:

; 727  :             if (state->head != Z_NULL)

  00339	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0033c	85 c0		 test	 eax, eax
  0033e	74 03		 je	 SHORT $LN355@inflate

; 728  :                 state->head->time = hold;

  00340	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN355@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00343	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  0034a	74 33		 je	 SHORT $LN53@inflate
  0034c	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00350	74 2d		 je	 SHORT $LN53@inflate

; 730  :                 CRC4(state->check, hold);

  00352	8b c2		 mov	 eax, edx
  00354	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00357	c1 e8 08	 shr	 eax, 8
  0035a	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  0035d	8b c2		 mov	 eax, edx
  0035f	c1 e8 10	 shr	 eax, 16			; 00000010H
  00362	88 45 e6	 mov	 BYTE PTR _hbuf$[ebp+2], al
  00365	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00368	6a 04		 push	 4
  0036a	c1 ea 18	 shr	 edx, 24			; 00000018H
  0036d	50		 push	 eax
  0036e	88 55 e7	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  00371	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00374	e8 00 00 00 00	 call	 _crc32@12
  00379	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0037c	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN53@inflate:

; 731  :             INITBITS();

  0037f	33 d2		 xor	 edx, edx

; 732  :             state->mode = OS;

  00381	c7 41 04 37 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16183 ; 00003f37H
  00388	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0038b	33 f6		 xor	 esi, esi

; 733  :         case OS:
; 734  :             NEEDBITS(16);

  0038d	eb 05		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  0038f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00392	73 27		 jae	 SHORT $LN58@inflate
$LL61@inflate:
  00394	85 db		 test	 ebx, ebx
  00396	0f 84 66 12 00
	00		 je	 $LN930@inflate
  0039c	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0039f	8b ce		 mov	 ecx, esi
  003a1	d3 e0		 shl	 eax, cl
  003a3	4b		 dec	 ebx
  003a4	03 d0		 add	 edx, eax
  003a6	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  003a9	47		 inc	 edi
  003aa	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  003ad	83 c6 08	 add	 esi, 8
  003b0	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  003b3	83 fe 10	 cmp	 esi, 16			; 00000010H
  003b6	72 dc		 jb	 SHORT $LL61@inflate
  003b8	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN58@inflate:

; 735  :             if (state->head != Z_NULL) {

  003bb	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  003be	8b c2		 mov	 eax, edx
  003c0	c1 e8 08	 shr	 eax, 8
  003c3	89 45 cc	 mov	 DWORD PTR $T10[ebp], eax
  003c6	85 f6		 test	 esi, esi
  003c8	74 11		 je	 SHORT $LN751@inflate

; 736  :                 state->head->xflags = (int)(hold & 0xff);

  003ca	0f b6 c2	 movzx	 eax, dl
  003cd	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 737  :                 state->head->os = (int)(hold >> 8);

  003d0	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  003d3	8b 75 cc	 mov	 esi, DWORD PTR $T10[ebp]
  003d6	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  003d9	8b c6		 mov	 eax, esi
$LN751@inflate:

; 738  :             }
; 739  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  003db	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  003e2	74 20		 je	 SHORT $LN67@inflate
  003e4	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  003e8	74 1a		 je	 SHORT $LN67@inflate

; 740  :                 CRC2(state->check, hold);

  003ea	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  003ed	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  003f0	6a 02		 push	 2
  003f2	50		 push	 eax
  003f3	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  003f6	ff 71 1c	 push	 DWORD PTR [ecx+28]
  003f9	e8 00 00 00 00	 call	 _crc32@12
  003fe	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00401	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN67@inflate:

; 741  :             INITBITS();

  00404	33 d2		 xor	 edx, edx

; 742  :             state->mode = EXLEN;

  00406	c7 41 04 38 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16184 ; 00003f38H
  0040d	33 f6		 xor	 esi, esi
  0040f	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00412	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN361@inflate:

; 743  :         case EXLEN:
; 744  :             if (state->flags & 0x0400) {

  00415	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  0041c	74 73		 je	 SHORT $LN362@inflate

; 745  :                 NEEDBITS(16);

  0041e	83 fe 10	 cmp	 esi, 16			; 00000010H
  00421	73 27		 jae	 SHORT $LN72@inflate
$LL75@inflate:
  00423	85 db		 test	 ebx, ebx
  00425	0f 84 d7 11 00
	00		 je	 $LN930@inflate
  0042b	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0042e	8b ce		 mov	 ecx, esi
  00430	d3 e0		 shl	 eax, cl
  00432	4b		 dec	 ebx
  00433	03 d0		 add	 edx, eax
  00435	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00438	47		 inc	 edi
  00439	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0043c	83 c6 08	 add	 esi, 8
  0043f	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00442	83 fe 10	 cmp	 esi, 16			; 00000010H
  00445	72 dc		 jb	 SHORT $LL75@inflate
  00447	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN72@inflate:

; 746  :                 state->length = (unsigned)(hold);
; 747  :                 if (state->head != Z_NULL)

  0044a	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0044d	89 51 44	 mov	 DWORD PTR [ecx+68], edx
  00450	85 c0		 test	 eax, eax
  00452	74 03		 je	 SHORT $LN365@inflate

; 748  :                     state->head->extra_len = (unsigned)hold;

  00454	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN365@inflate:

; 749  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00457	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  0045e	74 23		 je	 SHORT $LN81@inflate
  00460	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00464	74 1d		 je	 SHORT $LN81@inflate

; 750  :                     CRC2(state->check, hold);

  00466	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00469	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  0046c	6a 02		 push	 2
  0046e	c1 ea 08	 shr	 edx, 8
  00471	50		 push	 eax
  00472	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00475	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00478	e8 00 00 00 00	 call	 _crc32@12
  0047d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00480	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN81@inflate:

; 751  :                 INITBITS();

  00483	33 f6		 xor	 esi, esi
  00485	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  0048c	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 752  :             }

  0048f	eb 0e		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 753  :             else if (state->head != Z_NULL)

  00491	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00494	85 c0		 test	 eax, eax
  00496	74 07		 je	 SHORT $LN367@inflate

; 754  :                 state->head->extra = Z_NULL;

  00498	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN367@inflate:

; 755  :             state->mode = EXTRA;

  0049f	c7 41 04 39 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16185 ; 00003f39H
$LN368@inflate:

; 756  :         case EXTRA:
; 757  :             if (state->flags & 0x0400) {

  004a6	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  004a9	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  004ae	0f 84 9c 00 00
	00		 je	 $LN374@inflate

; 758  :                 copy = state->length;

  004b4	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]

; 759  :                 if (copy > have) copy = have;
; 760  :                 if (copy) {

  004b7	39 59 44	 cmp	 DWORD PTR [ecx+68], ebx
  004ba	89 55 cc	 mov	 DWORD PTR $T6[ebp], edx
  004bd	8b d3		 mov	 edx, ebx
  004bf	0f 46 51 44	 cmovbe	 edx, DWORD PTR [ecx+68]
  004c3	89 55 d4	 mov	 DWORD PTR tv5665[ebp], edx
  004c6	85 d2		 test	 edx, edx
  004c8	74 7b		 je	 SHORT $LN937@inflate

; 761  :                     if (state->head != Z_NULL &&

  004ca	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  004ce	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  004d1	74 45		 je	 SHORT $LN372@inflate
  004d3	8b 59 24	 mov	 ebx, DWORD PTR [ecx+36]
  004d6	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]
  004d9	85 db		 test	 ebx, ebx
  004db	89 5d ec	 mov	 DWORD PTR tv5524[ebp], ebx
  004de	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  004e1	74 35		 je	 SHORT $LN372@inflate

; 762  :                         state->head->extra != Z_NULL) {
; 763  :                         len = state->head->extra_len - state->length;

  004e3	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  004e6	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  004e9	2b 45 cc	 sub	 eax, DWORD PTR $T6[ebp]

; 764  :                         zmemcpy(state->head->extra + len, next,

  004ec	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  004ef	89 45 cc	 mov	 DWORD PTR _len$2$[ebp], eax
  004f2	03 c2		 add	 eax, edx
  004f4	3b c1		 cmp	 eax, ecx
  004f6	8b 45 cc	 mov	 eax, DWORD PTR _len$2$[ebp]
  004f9	76 04		 jbe	 SHORT $LN509@inflate
  004fb	2b c8		 sub	 ecx, eax
  004fd	eb 02		 jmp	 SHORT $LN510@inflate
$LN509@inflate:
  004ff	8b ca		 mov	 ecx, edx
$LN510@inflate:
  00501	03 45 ec	 add	 eax, DWORD PTR tv5524[ebp]
  00504	51		 push	 ecx
  00505	57		 push	 edi
  00506	50		 push	 eax
  00507	e8 00 00 00 00	 call	 _memcpy
  0050c	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0050f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00512	8b 55 d4	 mov	 edx, DWORD PTR tv5665[ebp]
  00515	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
$LN372@inflate:

; 765  :                                 len + copy > state->head->extra_max ?
; 766  :                                 state->head->extra_max - len : copy);
; 767  :                     }
; 768  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  00518	a9 00 02 00 00	 test	 eax, 512		; 00000200H
  0051d	74 16		 je	 SHORT $LN373@inflate
  0051f	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00523	74 10		 je	 SHORT $LN373@inflate

; 769  :                         state->check = crc32(state->check, next, copy);

  00525	52		 push	 edx
  00526	57		 push	 edi
  00527	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0052a	e8 00 00 00 00	 call	 _crc32@12
  0052f	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00532	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN373@inflate:

; 770  :                     have -= copy;

  00535	8b 45 d4	 mov	 eax, DWORD PTR tv5665[ebp]
  00538	2b d8		 sub	 ebx, eax

; 771  :                     next += copy;

  0053a	03 f8		 add	 edi, eax
  0053c	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx

; 772  :                     state->length -= copy;

  0053f	29 41 44	 sub	 DWORD PTR [ecx+68], eax
  00542	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
$LN937@inflate:

; 773  :                 }
; 774  :                 if (state->length) goto inf_leave;

  00545	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00548	85 c0		 test	 eax, eax
  0054a	0f 85 b2 10 00
	00		 jne	 $LN930@inflate
$LN374@inflate:

; 775  :             }
; 776  :             state->length = 0;

  00550	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 777  :             state->mode = NAME;

  00557	c7 41 04 3a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16186 ; 00003f3aH
$LN375@inflate:

; 778  :         case NAME:
; 779  :             if (state->flags & 0x0800) {

  0055e	f7 41 14 00 08
	00 00		 test	 DWORD PTR [ecx+20], 2048 ; 00000800H
  00565	0f 84 85 00 00
	00		 je	 $LN376@inflate

; 780  :                 if (have == 0) goto inf_leave;

  0056b	85 db		 test	 ebx, ebx
  0056d	0f 84 8f 10 00
	00		 je	 $LN930@inflate

; 781  :                 copy = 0;

  00573	33 d2		 xor	 edx, edx
$LL88@inflate:

; 782  :                 do {
; 783  :                     len = (unsigned)(next[copy++]);

  00575	8a 04 3a	 mov	 al, BYTE PTR [edx+edi]
  00578	42		 inc	 edx
  00579	88 45 ff	 mov	 BYTE PTR tv5664[ebp], al

; 784  :                     if (state->head != Z_NULL &&
; 785  :                             state->head->name != Z_NULL &&

  0057c	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0057f	85 c0		 test	 eax, eax
  00581	74 23		 je	 SHORT $LN86@inflate
  00583	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00586	89 75 cc	 mov	 DWORD PTR tv5522[ebp], esi
  00589	85 f6		 test	 esi, esi
  0058b	74 19		 je	 SHORT $LN86@inflate
  0058d	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  00590	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  00593	73 11		 jae	 SHORT $LN86@inflate

; 786  :                             state->length < state->head->name_max)
; 787  :                         state->head->name[state->length++] = (Bytef)len;

  00595	8a 5d ff	 mov	 bl, BYTE PTR tv5664[ebp]
  00598	8b c6		 mov	 eax, esi
  0059a	8b 75 cc	 mov	 esi, DWORD PTR tv5522[ebp]
  0059d	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  005a0	ff 41 44	 inc	 DWORD PTR [ecx+68]
  005a3	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN86@inflate:

; 788  :                 } while (len && copy < have);

  005a6	8a 45 ff	 mov	 al, BYTE PTR tv5664[ebp]
  005a9	84 c0		 test	 al, al
  005ab	74 04		 je	 SHORT $LN380@inflate
  005ad	3b d3		 cmp	 edx, ebx
  005af	72 c4		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 789  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  005b1	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  005b8	8b 75 e8	 mov	 esi, DWORD PTR _bits$1$[ebp]
  005bb	89 55 c4	 mov	 DWORD PTR _copy$1$[ebp], edx
  005be	74 1c		 je	 SHORT $LN381@inflate
  005c0	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  005c4	74 16		 je	 SHORT $LN381@inflate

; 790  :                     state->check = crc32(state->check, next, copy);

  005c6	52		 push	 edx
  005c7	57		 push	 edi
  005c8	ff 71 1c	 push	 DWORD PTR [ecx+28]
  005cb	e8 00 00 00 00	 call	 _crc32@12
  005d0	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  005d3	8b 55 c4	 mov	 edx, DWORD PTR _copy$1$[ebp]
  005d6	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  005d9	8a 45 ff	 mov	 al, BYTE PTR tv5664[ebp]
$LN381@inflate:

; 791  :                 have -= copy;

  005dc	2b da		 sub	 ebx, edx

; 792  :                 next += copy;

  005de	03 fa		 add	 edi, edx
  005e0	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  005e3	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi

; 793  :                 if (len) goto inf_leave;

  005e6	84 c0		 test	 al, al
  005e8	0f 85 14 10 00
	00		 jne	 $LN930@inflate

; 794  :             }

  005ee	eb 0e		 jmp	 SHORT $LN383@inflate
$LN376@inflate:

; 795  :             else if (state->head != Z_NULL)

  005f0	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  005f3	85 c0		 test	 eax, eax
  005f5	74 07		 je	 SHORT $LN383@inflate

; 796  :                 state->head->name = Z_NULL;

  005f7	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN383@inflate:

; 797  :             state->length = 0;

  005fe	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 798  :             state->mode = COMMENT;

  00605	c7 41 04 3b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16187 ; 00003f3bH
$LN384@inflate:

; 799  :         case COMMENT:
; 800  :             if (state->flags & 0x1000) {

  0060c	f7 41 14 00 10
	00 00		 test	 DWORD PTR [ecx+20], 4096 ; 00001000H
  00613	0f 84 85 00 00
	00		 je	 $LN385@inflate

; 801  :                 if (have == 0) goto inf_leave;

  00619	85 db		 test	 ebx, ebx
  0061b	0f 84 e1 0f 00
	00		 je	 $LN930@inflate

; 802  :                 copy = 0;

  00621	33 d2		 xor	 edx, edx
$LL91@inflate:

; 803  :                 do {
; 804  :                     len = (unsigned)(next[copy++]);

  00623	8a 04 3a	 mov	 al, BYTE PTR [edx+edi]
  00626	42		 inc	 edx
  00627	88 45 ff	 mov	 BYTE PTR tv5663[ebp], al

; 805  :                     if (state->head != Z_NULL &&
; 806  :                             state->head->comment != Z_NULL &&

  0062a	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0062d	85 c0		 test	 eax, eax
  0062f	74 23		 je	 SHORT $LN89@inflate
  00631	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  00634	89 75 cc	 mov	 DWORD PTR tv5521[ebp], esi
  00637	85 f6		 test	 esi, esi
  00639	74 19		 je	 SHORT $LN89@inflate
  0063b	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  0063e	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  00641	73 11		 jae	 SHORT $LN89@inflate

; 807  :                             state->length < state->head->comm_max)
; 808  :                         state->head->comment[state->length++] = (Bytef)len;

  00643	8a 5d ff	 mov	 bl, BYTE PTR tv5663[ebp]
  00646	8b c6		 mov	 eax, esi
  00648	8b 75 cc	 mov	 esi, DWORD PTR tv5521[ebp]
  0064b	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  0064e	ff 41 44	 inc	 DWORD PTR [ecx+68]
  00651	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN89@inflate:

; 809  :                 } while (len && copy < have);

  00654	8a 45 ff	 mov	 al, BYTE PTR tv5663[ebp]
  00657	84 c0		 test	 al, al
  00659	74 04		 je	 SHORT $LN389@inflate
  0065b	3b d3		 cmp	 edx, ebx
  0065d	72 c4		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 810  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  0065f	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00666	8b 75 e8	 mov	 esi, DWORD PTR _bits$1$[ebp]
  00669	89 55 c4	 mov	 DWORD PTR _copy$2$[ebp], edx
  0066c	74 1c		 je	 SHORT $LN390@inflate
  0066e	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00672	74 16		 je	 SHORT $LN390@inflate

; 811  :                     state->check = crc32(state->check, next, copy);

  00674	52		 push	 edx
  00675	57		 push	 edi
  00676	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00679	e8 00 00 00 00	 call	 _crc32@12
  0067e	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00681	8b 55 c4	 mov	 edx, DWORD PTR _copy$2$[ebp]
  00684	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00687	8a 45 ff	 mov	 al, BYTE PTR tv5663[ebp]
$LN390@inflate:

; 812  :                 have -= copy;

  0068a	2b da		 sub	 ebx, edx

; 813  :                 next += copy;

  0068c	03 fa		 add	 edi, edx
  0068e	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00691	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi

; 814  :                 if (len) goto inf_leave;

  00694	84 c0		 test	 al, al
  00696	0f 85 66 0f 00
	00		 jne	 $LN930@inflate

; 815  :             }

  0069c	eb 0e		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 816  :             else if (state->head != Z_NULL)

  0069e	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  006a1	85 c0		 test	 eax, eax
  006a3	74 07		 je	 SHORT $LN392@inflate

; 817  :                 state->head->comment = Z_NULL;

  006a5	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN392@inflate:
  006ac	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 818  :             state->mode = HCRC;

  006af	c7 41 04 3c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16188 ; 00003f3cH
$LN393@inflate:

; 819  :         case HCRC:
; 820  :             if (state->flags & 0x0200) {

  006b6	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  006b9	89 45 c4	 mov	 DWORD PTR tv5246[ebp], eax
  006bc	a9 00 02 00 00	 test	 eax, 512		; 00000200H
  006c1	74 5f		 je	 SHORT $LN101@inflate

; 821  :                 NEEDBITS(16);

  006c3	83 fe 10	 cmp	 esi, 16			; 00000010H
  006c6	73 2a		 jae	 SHORT $LN92@inflate
$LL95@inflate:
  006c8	85 db		 test	 ebx, ebx
  006ca	0f 84 32 0f 00
	00		 je	 $LN930@inflate
  006d0	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  006d3	8b ce		 mov	 ecx, esi
  006d5	d3 e0		 shl	 eax, cl
  006d7	83 c6 08	 add	 esi, 8
  006da	4b		 dec	 ebx
  006db	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  006de	03 d0		 add	 edx, eax
  006e0	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  006e3	47		 inc	 edi
  006e4	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  006e7	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  006ea	83 fe 10	 cmp	 esi, 16			; 00000010H
  006ed	72 d9		 jb	 SHORT $LL95@inflate
  006ef	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN92@inflate:

; 822  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  006f2	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  006f6	74 1e		 je	 SHORT $LN102@inflate
  006f8	0f b7 41 1c	 movzx	 eax, WORD PTR [ecx+28]
  006fc	3b d0		 cmp	 edx, eax
  006fe	74 16		 je	 SHORT $LN102@inflate

; 823  :                     strm->msg = (char *)"header crc mismatch";

  00700	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00703	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
  0070a	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00711	e9 f8 09 00 00	 jmp	 $LN8@inflate
$LN102@inflate:

; 824  :                     state->mode = BAD;
; 825  :                     break;
; 826  :                 }
; 827  :                 INITBITS();

  00716	33 f6		 xor	 esi, esi
  00718	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  0071f	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN101@inflate:

; 828  :             }
; 829  :             if (state->head != Z_NULL) {

  00722	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00725	85 c0		 test	 eax, eax
  00727	74 16		 je	 SHORT $LN397@inflate

; 830  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00729	8b 55 c4	 mov	 edx, DWORD PTR tv5246[ebp]
  0072c	c1 fa 09	 sar	 edx, 9
  0072f	83 e2 01	 and	 edx, 1
  00732	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 831  :                 state->head->done = 1;

  00735	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00738	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN397@inflate:

; 832  :             }
; 833  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  0073f	6a 00		 push	 0
  00741	6a 00		 push	 0
  00743	6a 00		 push	 0
  00745	e8 00 00 00 00	 call	 _crc32@12
  0074a	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0074d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00750	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00753	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 834  :             state->mode = TYPE;
; 835  :             break;

  00756	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00759	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  00760	e9 a9 09 00 00	 jmp	 $LN8@inflate
$LN105@inflate:

; 836  : #endif
; 837  :         case DICTID:
; 838  :             NEEDBITS(32);

  00765	83 fe 20	 cmp	 esi, 32			; 00000020H
  00768	73 2a		 jae	 SHORT $LN103@inflate
  0076a	66 0f 1f 44 00
	00		 npad	 6
$LL106@inflate:
  00770	85 db		 test	 ebx, ebx
  00772	0f 84 8a 0e 00
	00		 je	 $LN930@inflate
  00778	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0077b	8b ce		 mov	 ecx, esi
  0077d	d3 e0		 shl	 eax, cl
  0077f	4b		 dec	 ebx
  00780	03 d0		 add	 edx, eax
  00782	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00785	47		 inc	 edi
  00786	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00789	83 c6 08	 add	 esi, 8
  0078c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0078f	83 fe 20	 cmp	 esi, 32			; 00000020H
  00792	72 dc		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 839  :             strm->adler = state->check = ZSWAP32(hold);

  00794	8b ca		 mov	 ecx, edx
  00796	8b c2		 mov	 eax, edx
  00798	c1 e0 10	 shl	 eax, 16			; 00000010H
  0079b	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007a1	03 c8		 add	 ecx, eax
  007a3	8b c2		 mov	 eax, edx
  007a5	c1 e8 08	 shr	 eax, 8
  007a8	c1 e1 08	 shl	 ecx, 8
  007ab	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  007b0	c1 ea 18	 shr	 edx, 24			; 00000018H
  007b3	03 c1		 add	 eax, ecx
  007b5	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007b8	03 c2		 add	 eax, edx
  007ba	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007bd	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  007c0	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 840  :             INITBITS();

  007c3	33 d2		 xor	 edx, edx
  007c5	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  007c8	33 f6		 xor	 esi, esi

; 841  :             state->mode = DICT;

  007ca	c7 41 04 3e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16190 ; 00003f3eH
$LN400@inflate:

; 842  :         case DICT:
; 843  :             if (state->havedict == 0) {

  007d1	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  007d5	0f 84 d0 0d 00
	00		 je	 $LN586@inflate

; 846  :             }
; 847  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  007db	6a 00		 push	 0
  007dd	6a 00		 push	 0
  007df	6a 00		 push	 0
  007e1	e8 00 00 00 00	 call	 _adler32@12
  007e6	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007e9	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007ec	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  007ef	89 42 30	 mov	 DWORD PTR [edx+48], eax
  007f2	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 848  :             state->mode = TYPE;

  007f5	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
$LN402@inflate:

; 849  :         case TYPE:
; 850  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  007fc	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  007ff	83 f8 05	 cmp	 eax, 5
  00802	0f 84 fa 0d 00
	00		 je	 $LN930@inflate
  00808	83 f8 06	 cmp	 eax, 6
  0080b	0f 84 f1 0d 00
	00		 je	 $LN930@inflate
$LN403@inflate:

; 851  :         case TYPEDO:
; 852  :             if (state->last) {

  00811	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00815	74 1e		 je	 SHORT $LN122@inflate

; 853  :                 BYTEBITS();

  00817	8b ce		 mov	 ecx, esi
  00819	83 e1 07	 and	 ecx, 7
  0081c	d3 ea		 shr	 edx, cl
  0081e	2b f1		 sub	 esi, ecx

; 854  :                 state->mode = CHECK;

  00820	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00823	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00826	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00829	c7 41 04 4e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16206 ; 00003f4eH

; 855  :                 break;

  00830	e9 d9 08 00 00	 jmp	 $LN8@inflate
$LN122@inflate:

; 856  :             }
; 857  :             NEEDBITS(3);

  00835	83 fe 03	 cmp	 esi, 3
  00838	73 2d		 jae	 SHORT $LN120@inflate
  0083a	66 0f 1f 44 00
	00		 npad	 6
$LL123@inflate:
  00840	85 db		 test	 ebx, ebx
  00842	0f 84 ba 0d 00
	00		 je	 $LN930@inflate
  00848	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0084b	8b ce		 mov	 ecx, esi
  0084d	d3 e0		 shl	 eax, cl
  0084f	4b		 dec	 ebx
  00850	03 d0		 add	 edx, eax
  00852	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00855	47		 inc	 edi
  00856	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00859	83 c6 08	 add	 esi, 8
  0085c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0085f	83 fe 03	 cmp	 esi, 3
  00862	72 dc		 jb	 SHORT $LL123@inflate
  00864	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN120@inflate:

; 858  :             state->last = BITS(1);

  00867	8b c2		 mov	 eax, edx

; 859  :             DROPBITS(1);

  00869	d1 ea		 shr	 edx, 1
  0086b	83 e0 01	 and	 eax, 1
  0086e	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00871	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 860  :             switch (BITS(2)) {

  00874	8b c2		 mov	 eax, edx
  00876	83 e0 03	 and	 eax, 3
  00879	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN980@inflate[eax*4]
$LN408@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  00880	c1 ea 02	 shr	 edx, 2
  00883	83 ee 03	 sub	 esi, 3
  00886	c7 41 04 41 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16193 ; 00003f41H
  0088d	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00890	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  00893	e9 76 08 00 00	 jmp	 $LN8@inflate
$LN409@inflate:

; 861  :             case 0:                             /* stored block */
; 862  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 863  :                         state->last ? " (last)" : ""));
; 864  :                 state->mode = STORED;
; 865  :                 break;
; 866  :             case 1:                             /* fixed block */
; 867  :                 fixedtables(state);

  00898	e8 00 00 00 00	 call	 _fixedtables

; 868  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 869  :                         state->last ? " (last)" : ""));
; 870  :                 state->mode = LEN_;             /* decode codes */

  0089d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 871  :                 if (flush == Z_TREES) {

  008a0	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  008a3	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  008aa	83 fa 06	 cmp	 edx, 6
  008ad	0f 84 23 0d 00
	00		 je	 $LN587@inflate

; 873  :                     goto inf_leave;
; 874  :                 }
; 875  :                 break;

  008b3	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 884  :             }
; 885  :             DROPBITS(2);

  008b6	c1 ea 02	 shr	 edx, 2
  008b9	83 ee 03	 sub	 esi, 3
  008bc	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  008bf	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  008c2	e9 47 08 00 00	 jmp	 $LN8@inflate
$LN411@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  008c7	c1 ea 02	 shr	 edx, 2
  008ca	83 ee 03	 sub	 esi, 3
  008cd	c7 41 04 44 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16196 ; 00003f44H
  008d4	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  008d7	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  008da	e9 2f 08 00 00	 jmp	 $LN8@inflate
$LN412@inflate:

; 876  :             case 2:                             /* dynamic block */
; 877  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = TABLE;
; 880  :                 break;
; 881  :             case 3:
; 882  :                 strm->msg = (char *)"invalid block type";

  008df	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  008e2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 883  :                 state->mode = BAD;

  008e9	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN138@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  008f0	c1 ea 02	 shr	 edx, 2
  008f3	83 ee 03	 sub	 esi, 3
  008f6	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  008f9	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  008fc	e9 0d 08 00 00	 jmp	 $LN8@inflate
$LN141@inflate:

; 887  :         case STORED:
; 888  :             BYTEBITS();                         /* go to byte boundary */

  00901	8b ce		 mov	 ecx, esi
  00903	83 e1 07	 and	 ecx, 7
  00906	2b f1		 sub	 esi, ecx
  00908	d3 ea		 shr	 edx, cl
  0090a	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0090d	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 889  :             NEEDBITS(32);

  00910	83 fe 20	 cmp	 esi, 32			; 00000020H
  00913	73 27		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  00915	85 db		 test	 ebx, ebx
  00917	0f 84 e5 0c 00
	00		 je	 $LN930@inflate
  0091d	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00920	8b ce		 mov	 ecx, esi
  00922	d3 e0		 shl	 eax, cl
  00924	83 c6 08	 add	 esi, 8
  00927	4b		 dec	 ebx
  00928	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0092b	03 d0		 add	 edx, eax
  0092d	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00930	47		 inc	 edi
  00931	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00934	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00937	83 fe 20	 cmp	 esi, 32			; 00000020H
  0093a	72 d9		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 890  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  0093c	8b c2		 mov	 eax, edx
  0093e	0f b7 ca	 movzx	 ecx, dx
  00941	f7 d0		 not	 eax
  00943	89 4d c4	 mov	 DWORD PTR tv5519[ebp], ecx
  00946	c1 e8 10	 shr	 eax, 16			; 00000010H
  00949	3b c8		 cmp	 ecx, eax
  0094b	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0094e	74 16		 je	 SHORT $LN415@inflate

; 891  :                 strm->msg = (char *)"invalid stored block lengths";

  00950	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00953	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  0095a	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00961	e9 a8 07 00 00	 jmp	 $LN8@inflate
$LN415@inflate:

; 892  :                 state->mode = BAD;
; 893  :                 break;
; 894  :             }
; 895  :             state->length = (unsigned)hold & 0xffff;

  00966	8b 45 c4	 mov	 eax, DWORD PTR tv5519[ebp]

; 896  :             Tracev((stderr, "inflate:       stored length %u\n",
; 897  :                     state->length));
; 898  :             INITBITS();

  00969	33 d2		 xor	 edx, edx
  0096b	33 f6		 xor	 esi, esi
  0096d	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 899  :             state->mode = COPY_;
; 900  :             if (flush == Z_TREES) goto inf_leave;

  00970	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00974	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00977	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0097a	c7 41 04 42 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16194 ; 00003f42H
  00981	0f 84 7b 0c 00
	00		 je	 $LN930@inflate
$LN416@inflate:

; 901  :         case COPY_:
; 902  :             state->mode = COPY;

  00987	c7 41 04 43 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16195 ; 00003f43H
$LN418@inflate:

; 903  :         case COPY:
; 904  :             copy = state->length;

  0098e	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00991	89 45 c4	 mov	 DWORD PTR _copy$3$[ebp], eax

; 905  :             if (copy) {

  00994	85 c0		 test	 eax, eax
  00996	74 4a		 je	 SHORT $LN419@inflate

; 906  :                 if (copy > have) copy = have;
; 907  :                 if (copy > left) copy = left;

  00998	39 5d c4	 cmp	 DWORD PTR _copy$3$[ebp], ebx
  0099b	8b c3		 mov	 eax, ebx

; 908  :                 if (copy == 0) goto inf_leave;

  0099d	8b 4d e0	 mov	 ecx, DWORD PTR _left$1$[ebp]
  009a0	0f 46 45 c4	 cmovbe	 eax, DWORD PTR _copy$3$[ebp]
  009a4	3b c1		 cmp	 eax, ecx
  009a6	0f 46 c8	 cmovbe	 ecx, eax
  009a9	89 4d c4	 mov	 DWORD PTR tv5661[ebp], ecx
  009ac	85 c9		 test	 ecx, ecx
  009ae	0f 84 4e 0c 00
	00		 je	 $LN930@inflate

; 909  :                 zmemcpy(put, next, copy);

  009b4	51		 push	 ecx
  009b5	57		 push	 edi
  009b6	ff 75 dc	 push	 DWORD PTR _put$1$[ebp]
  009b9	e8 00 00 00 00	 call	 _memcpy

; 910  :                 have -= copy;

  009be	8b 45 c4	 mov	 eax, DWORD PTR tv5661[ebp]
  009c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 911  :                 next += copy;
; 912  :                 left -= copy;
; 913  :                 put += copy;
; 914  :                 state->length -= copy;

  009c4	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  009c7	2b d8		 sub	 ebx, eax
  009c9	29 45 e0	 sub	 DWORD PTR _left$1$[ebp], eax
  009cc	03 f8		 add	 edi, eax
  009ce	01 45 dc	 add	 DWORD PTR _put$1$[ebp], eax

; 915  :                 break;

  009d1	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  009d4	29 41 44	 sub	 DWORD PTR [ecx+68], eax
  009d7	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  009da	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  009dd	e9 2c 07 00 00	 jmp	 $LN8@inflate
$LN419@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       stored end\n"));
; 918  :             state->mode = TYPE;

  009e2	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 919  :             break;

  009e9	e9 20 07 00 00	 jmp	 $LN8@inflate
$LN155@inflate:

; 920  :         case TABLE:
; 921  :             NEEDBITS(14);

  009ee	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  009f1	73 24		 jae	 SHORT $LN153@inflate
$LL156@inflate:
  009f3	85 db		 test	 ebx, ebx
  009f5	0f 84 07 0c 00
	00		 je	 $LN930@inflate
  009fb	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  009fe	8b ce		 mov	 ecx, esi
  00a00	d3 e0		 shl	 eax, cl
  00a02	4b		 dec	 ebx
  00a03	03 d0		 add	 edx, eax
  00a05	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a08	47		 inc	 edi
  00a09	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a0c	83 c6 08	 add	 esi, 8
  00a0f	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00a12	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a15	72 dc		 jb	 SHORT $LL156@inflate
$LN153@inflate:

; 922  :             state->nlen = BITS(5) + 257;

  00a17	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00a1a	8b ca		 mov	 ecx, edx

; 923  :             DROPBITS(5);

  00a1c	c1 ea 05	 shr	 edx, 5
  00a1f	83 e1 1f	 and	 ecx, 31			; 0000001fH

; 924  :             state->ndist = BITS(5) + 1;

  00a22	8b fa		 mov	 edi, edx
  00a24	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00a2a	83 e7 1f	 and	 edi, 31			; 0000001fH

; 925  :             DROPBITS(5);

  00a2d	c1 ea 05	 shr	 edx, 5
  00a30	47		 inc	 edi
  00a31	89 48 64	 mov	 DWORD PTR [eax+100], ecx
  00a34	89 78 68	 mov	 DWORD PTR [eax+104], edi

; 926  :             state->ncode = BITS(4) + 4;
; 927  :             DROPBITS(4);

  00a37	83 ee 0e	 sub	 esi, 14			; 0000000eH
  00a3a	89 7d c4	 mov	 DWORD PTR tv5684[ebp], edi
  00a3d	8b c2		 mov	 eax, edx
  00a3f	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  00a42	83 e0 0f	 and	 eax, 15			; 0000000fH
  00a45	83 c0 04	 add	 eax, 4
  00a48	c1 ea 04	 shr	 edx, 4
  00a4b	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a4e	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a51	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 928  : #ifndef PKZIP_BUG_WORKAROUND
; 929  :             if (state->nlen > 286 || state->ndist > 30) {

  00a54	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00a57	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00a5d	0f 87 00 01 00
	00		 ja	 $LN426@inflate
  00a63	83 7d c4 1e	 cmp	 DWORD PTR tv5684[ebp], 30 ; 0000001eH
  00a67	0f 87 f6 00 00
	00		 ja	 $LN426@inflate

; 932  :                 break;
; 933  :             }
; 934  : #endif
; 935  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 936  :             state->have = 0;

  00a6d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00a70	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 937  :             state->mode = LENLENS;

  00a77	c7 41 04 45 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16197 ; 00003f45H
$LN532@inflate:

; 938  :         case LENLENS:
; 939  :             while (state->have < state->ncode) {

  00a7e	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00a81	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00a84	73 65		 jae	 SHORT $LN534@inflate
$LL170@inflate:

; 940  :                 NEEDBITS(3);

  00a86	83 fe 03	 cmp	 esi, 3
  00a89	73 29		 jae	 SHORT $LN172@inflate
  00a8b	0f 1f 44 00 00	 npad	 5
$LL175@inflate:
  00a90	85 db		 test	 ebx, ebx
  00a92	0f 84 6a 0b 00
	00		 je	 $LN930@inflate
  00a98	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00a9b	8b ce		 mov	 ecx, esi
  00a9d	d3 e0		 shl	 eax, cl
  00a9f	4b		 dec	 ebx
  00aa0	03 d0		 add	 edx, eax
  00aa2	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00aa5	47		 inc	 edi
  00aa6	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00aa9	83 c6 08	 add	 esi, 8
  00aac	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00aaf	83 fe 03	 cmp	 esi, 3
  00ab2	72 dc		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 941  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00ab4	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00ab7	8b ca		 mov	 ecx, edx
  00ab9	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  00abc	83 e1 07	 and	 ecx, 7

; 942  :                 DROPBITS(3);

  00abf	c1 ea 03	 shr	 edx, 3
  00ac2	83 ee 03	 sub	 esi, 3
  00ac5	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ac8	8b 40 6c	 mov	 eax, DWORD PTR [eax+108]
  00acb	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00ace	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00ad6	66 89 4c 47 74	 mov	 WORD PTR [edi+eax*2+116], cx
  00adb	8b cf		 mov	 ecx, edi
  00add	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00ae0	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00ae3	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00ae6	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00ae9	72 9b		 jb	 SHORT $LL170@inflate
$LN534@inflate:

; 943  :             }
; 944  :             while (state->have < 19)

  00aeb	83 f8 13	 cmp	 eax, 19			; 00000013H
  00aee	73 1b		 jae	 SHORT $LN184@inflate
$LL183@inflate:

; 945  :                 state->lens[order[state->have++]] = 0;

  00af0	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00af3	33 d2		 xor	 edx, edx
  00af5	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00afd	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00b02	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00b05	83 79 6c 13	 cmp	 DWORD PTR [ecx+108], 19	; 00000013H
  00b09	72 e5		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 946  :             state->next = state->codes;

  00b0b	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]

; 947  :             state->lencode = (const code FAR *)(state->next);
; 948  :             state->lenbits = 7;

  00b11	c7 41 58 07 00
	00 00		 mov	 DWORD PTR [ecx+88], 7
  00b18	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]
  00b1b	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00b1e	89 02		 mov	 DWORD PTR [edx], eax
  00b20	83 c1 58	 add	 ecx, 88			; 00000058H

; 949  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00b23	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00b26	05 f4 02 00 00	 add	 eax, 756		; 000002f4H
  00b2b	50		 push	 eax
  00b2c	51		 push	 ecx
  00b2d	52		 push	 edx
  00b2e	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00b31	33 c9		 xor	 ecx, ecx
  00b33	6a 13		 push	 19			; 00000013H
  00b35	8d 52 74	 lea	 edx, DWORD PTR [edx+116]
  00b38	e8 00 00 00 00	 call	 _inflate_table

; 950  :                                 &(state->lenbits), state->work);
; 951  :             if (ret) {

  00b3d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00b40	83 c4 10	 add	 esp, 16			; 00000010H
  00b43	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00b46	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax
  00b49	85 c0		 test	 eax, eax
  00b4b	74 2f		 je	 SHORT $LN429@inflate

; 952  :                 strm->msg = (char *)"invalid code lengths set";

  00b4d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b50	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
  00b57	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00b5e	e9 ab 05 00 00	 jmp	 $LN8@inflate
$LN426@inflate:

; 930  :                 strm->msg = (char *)"too many length or distance symbols";

  00b63	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 931  :                 state->mode = BAD;

  00b66	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00b69	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  00b70	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00b77	e9 92 05 00 00	 jmp	 $LN8@inflate
$LN429@inflate:

; 953  :                 state->mode = BAD;
; 954  :                 break;
; 955  :             }
; 956  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 957  :             state->have = 0;

  00b7c	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 958  :             state->mode = CODELENS;

  00b83	c7 41 04 46 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16198 ; 00003f46H
  00b8a	c7 45 d4 46 3f
	00 00		 mov	 DWORD PTR $T13[ebp], 16198 ; 00003f46H
$LN535@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00b91	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00b94	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00b97	39 41 6c	 cmp	 DWORD PTR [ecx+108], eax
  00b9a	0f 83 6c 02 00
	00		 jae	 $LN936@inflate
$LL185@inflate:

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  00ba0	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00ba3	b8 01 00 00 00	 mov	 eax, 1
  00ba8	d3 e0		 shl	 eax, cl
  00baa	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00bad	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bb0	89 4d c4	 mov	 DWORD PTR tv5515[ebp], ecx
  00bb3	23 ca		 and	 ecx, edx
  00bb5	8b 78 50	 mov	 edi, DWORD PTR [eax+80]
  00bb8	89 7d cc	 mov	 DWORD PTR tv5560[ebp], edi
  00bbb	8b 04 8f	 mov	 eax, DWORD PTR [edi+ecx*4]
  00bbe	8b c8		 mov	 ecx, eax
  00bc0	c1 e9 08	 shr	 ecx, 8
  00bc3	8b f8		 mov	 edi, eax
  00bc5	c1 ef 10	 shr	 edi, 16			; 00000010H
  00bc8	89 4d d4	 mov	 DWORD PTR $T12[ebp], ecx
  00bcb	0f b6 c9	 movzx	 ecx, cl
  00bce	89 7d e8	 mov	 DWORD PTR $T14[ebp], edi

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  00bd1	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00bd4	3b ce		 cmp	 ecx, esi
  00bd6	76 44		 jbe	 SHORT $LN655@inflate
$LL187@inflate:

; 964  :                     PULLBYTE();

  00bd8	85 db		 test	 ebx, ebx
  00bda	0f 84 22 0a 00
	00		 je	 $LN930@inflate
  00be0	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00be3	8b ce		 mov	 ecx, esi
  00be5	d3 e0		 shl	 eax, cl
  00be7	4b		 dec	 ebx
  00be8	8b 4d cc	 mov	 ecx, DWORD PTR tv5560[ebp]
  00beb	03 d0		 add	 edx, eax
  00bed	8b 45 c4	 mov	 eax, DWORD PTR tv5515[ebp]
  00bf0	47		 inc	 edi
  00bf1	23 c2		 and	 eax, edx
  00bf3	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00bf6	83 c6 08	 add	 esi, 8
  00bf9	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00bfc	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00bff	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00c02	8b c8		 mov	 ecx, eax
  00c04	c1 e9 08	 shr	 ecx, 8
  00c07	8b d8		 mov	 ebx, eax
  00c09	c1 eb 10	 shr	 ebx, 16			; 00000010H
  00c0c	89 4d d4	 mov	 DWORD PTR $T12[ebp], ecx
  00c0f	0f b6 c9	 movzx	 ecx, cl
  00c12	89 5d e8	 mov	 DWORD PTR $T14[ebp], ebx
  00c15	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  00c18	3b ce		 cmp	 ecx, esi
  00c1a	77 bc		 ja	 SHORT $LL187@inflate
$LN655@inflate:

; 965  :                 }
; 966  :                 if (here.val < 16) {

  00c1c	8b 5d e8	 mov	 ebx, DWORD PTR $T14[ebp]
  00c1f	8b 4d d4	 mov	 ecx, DWORD PTR $T12[ebp]
  00c22	0f b7 db	 movzx	 ebx, bx
  00c25	89 5d c0	 mov	 DWORD PTR tv5496[ebp], ebx
  00c28	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00c2b	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  00c2e	89 4d c4	 mov	 DWORD PTR $T1[ebp], ecx
  00c31	89 4d d4	 mov	 DWORD PTR $T11[ebp], ecx
  00c34	89 4d cc	 mov	 DWORD PTR $T5[ebp], ecx
  00c37	73 2e		 jae	 SHORT $LN433@inflate

; 967  :                     DROPBITS(here.bits);
; 968  :                     state->lens[state->have++] = here.val;

  00c39	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  00c3c	d3 ea		 shr	 edx, cl
  00c3e	0f b6 c9	 movzx	 ecx, cl
  00c41	2b f1		 sub	 esi, ecx
  00c43	c1 e8 10	 shr	 eax, 16			; 00000010H
  00c46	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c49	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c4c	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c4f	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  00c52	66 89 44 4f 74	 mov	 WORD PTR [edi+ecx*2+116], ax
  00c57	8b cf		 mov	 ecx, edi
  00c59	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00c5c	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00c5f	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax

; 969  :                 }

  00c62	e9 78 01 00 00	 jmp	 $LN971@inflate
$LN433@inflate:

; 970  :                 else {
; 971  :                     if (here.val == 16) {

  00c67	66 83 7d e8 10	 cmp	 WORD PTR $T14[ebp], 16	; 00000010H
  00c6c	75 72		 jne	 SHORT $LN435@inflate

; 972  :                         NEEDBITS(here.bits + 2);

  00c6e	8b 4d d4	 mov	 ecx, DWORD PTR $T11[ebp]
  00c71	0f b6 c9	 movzx	 ecx, cl
  00c74	83 c1 02	 add	 ecx, 2
  00c77	89 4d c4	 mov	 DWORD PTR tv5553[ebp], ecx
  00c7a	3b f1		 cmp	 esi, ecx
  00c7c	73 27		 jae	 SHORT $LN196@inflate
  00c7e	66 90		 npad	 2
$LL199@inflate:
  00c80	85 db		 test	 ebx, ebx
  00c82	0f 84 7a 09 00
	00		 je	 $LN930@inflate
  00c88	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00c8b	8b ce		 mov	 ecx, esi
  00c8d	d3 e2		 shl	 edx, cl
  00c8f	4b		 dec	 ebx
  00c90	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00c93	47		 inc	 edi
  00c94	83 c6 08	 add	 esi, 8
  00c97	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c9a	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00c9d	3b 75 c4	 cmp	 esi, DWORD PTR tv5553[ebp]
  00ca0	72 de		 jb	 SHORT $LL199@inflate
  00ca2	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN196@inflate:

; 973  :                         DROPBITS(here.bits);

  00ca5	0f b6 cc	 movzx	 ecx, ah
  00ca8	d3 ea		 shr	 edx, cl
  00caa	2b f1		 sub	 esi, ecx

; 974  :                         if (state->have == 0) {

  00cac	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00caf	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cb2	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00cb5	83 79 6c 00	 cmp	 DWORD PTR [ecx+108], 0
  00cb9	0f 84 37 01 00
	00		 je	 $LN567@inflate

; 975  :                             strm->msg = (char *)"invalid bit length repeat";
; 976  :                             state->mode = BAD;
; 977  :                             break;
; 978  :                         }
; 979  :                         len = state->lens[state->have - 1];
; 980  :                         copy = 3 + BITS(2);
; 981  :                         DROPBITS(2);

  00cbf	8b 79 6c	 mov	 edi, DWORD PTR [ecx+108]
  00cc2	8b c2		 mov	 eax, edx
  00cc4	83 e0 03	 and	 eax, 3
  00cc7	c1 ea 02	 shr	 edx, 2
  00cca	83 c0 03	 add	 eax, 3
  00ccd	83 ee 02	 sub	 esi, 2
  00cd0	89 45 d4	 mov	 DWORD PTR _copy$4$[ebp], eax
  00cd3	0f b7 7c 79 72	 movzx	 edi, WORD PTR [ecx+edi*2+114]
  00cd8	89 7d cc	 mov	 DWORD PTR $T9[ebp], edi

; 982  :                     }

  00cdb	e9 b5 00 00 00	 jmp	 $LN972@inflate
$LN435@inflate:

; 983  :                     else if (here.val == 17) {

  00ce0	66 83 7d c0 11	 cmp	 WORD PTR tv5496[ebp], 17 ; 00000011H
  00ce5	8b 4d c4	 mov	 ecx, DWORD PTR $T1[ebp]
  00ce8	0f b6 c9	 movzx	 ecx, cl
  00ceb	89 4d c4	 mov	 DWORD PTR tv5671[ebp], ecx
  00cee	75 4b		 jne	 SHORT $LN226@inflate

; 984  :                         NEEDBITS(here.bits + 3);

  00cf0	83 c1 03	 add	 ecx, 3
  00cf3	3b f1		 cmp	 esi, ecx
  00cf5	73 2a		 jae	 SHORT $LN210@inflate
$LL213@inflate:
  00cf7	85 db		 test	 ebx, ebx
  00cf9	0f 84 03 09 00
	00		 je	 $LN930@inflate
  00cff	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00d02	8b ce		 mov	 ecx, esi
  00d04	d3 e2		 shl	 edx, cl
  00d06	4b		 dec	 ebx
  00d07	8b 4d c4	 mov	 ecx, DWORD PTR tv5671[ebp]
  00d0a	47		 inc	 edi
  00d0b	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00d0e	83 c6 08	 add	 esi, 8
  00d11	83 c1 03	 add	 ecx, 3
  00d14	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00d17	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00d1a	3b f1		 cmp	 esi, ecx
  00d1c	72 d9		 jb	 SHORT $LL213@inflate
  00d1e	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN210@inflate:

; 985  :                         DROPBITS(here.bits);

  00d21	0f b6 cc	 movzx	 ecx, ah
  00d24	d3 ea		 shr	 edx, cl

; 986  :                         len = 0;
; 987  :                         copy = 3 + BITS(3);

  00d26	8b c2		 mov	 eax, edx
  00d28	83 e0 07	 and	 eax, 7
  00d2b	83 c0 03	 add	 eax, 3

; 988  :                         DROPBITS(3);

  00d2e	c1 ea 03	 shr	 edx, 3
  00d31	89 45 d4	 mov	 DWORD PTR _copy$4$[ebp], eax
  00d34	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 989  :                     }

  00d39	eb 49		 jmp	 SHORT $LN973@inflate
$LN226@inflate:

; 990  :                     else {
; 991  :                         NEEDBITS(here.bits + 7);

  00d3b	83 c1 07	 add	 ecx, 7
  00d3e	3b f1		 cmp	 esi, ecx
  00d40	73 2a		 jae	 SHORT $LN224@inflate
$LL227@inflate:
  00d42	85 db		 test	 ebx, ebx
  00d44	0f 84 b8 08 00
	00		 je	 $LN930@inflate
  00d4a	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00d4d	8b ce		 mov	 ecx, esi
  00d4f	d3 e2		 shl	 edx, cl
  00d51	4b		 dec	 ebx
  00d52	8b 4d c4	 mov	 ecx, DWORD PTR tv5671[ebp]
  00d55	47		 inc	 edi
  00d56	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00d59	83 c6 08	 add	 esi, 8
  00d5c	83 c1 07	 add	 ecx, 7
  00d5f	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00d62	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00d65	3b f1		 cmp	 esi, ecx
  00d67	72 d9		 jb	 SHORT $LL227@inflate
  00d69	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN224@inflate:

; 992  :                         DROPBITS(here.bits);

  00d6c	0f b6 cc	 movzx	 ecx, ah
  00d6f	d3 ea		 shr	 edx, cl

; 993  :                         len = 0;
; 994  :                         copy = 11 + BITS(7);

  00d71	8b c2		 mov	 eax, edx
  00d73	83 e0 7f	 and	 eax, 127		; 0000007fH
  00d76	83 c0 0b	 add	 eax, 11			; 0000000bH

; 995  :                         DROPBITS(7);

  00d79	c1 ea 07	 shr	 edx, 7
  00d7c	89 45 d4	 mov	 DWORD PTR _copy$4$[ebp], eax
  00d7f	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN973@inflate:

; 996  :                     }
; 997  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d84	2b c1		 sub	 eax, ecx
  00d86	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T9[ebp], 0
  00d8d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d90	03 f0		 add	 esi, eax
  00d92	8b 45 d4	 mov	 eax, DWORD PTR _copy$4$[ebp]
$LN972@inflate:
  00d95	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  00d98	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  00d9b	03 c8		 add	 ecx, eax
  00d9d	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00da0	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00da3	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00da6	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  00da9	03 47 64	 add	 eax, DWORD PTR [edi+100]
  00dac	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00daf	3b c8		 cmp	 ecx, eax
  00db1	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00db4	77 40		 ja	 SHORT $LN567@inflate
  00db6	8b 5d d4	 mov	 ebx, DWORD PTR _copy$4$[ebp]
  00db9	8b 55 cc	 mov	 edx, DWORD PTR $T9[ebp]
  00dbc	0f 1f 40 00	 npad	 4
$LL238@inflate:

; 998  :                         strm->msg = (char *)"invalid bit length repeat";
; 999  :                         state->mode = BAD;
; 1000 :                         break;
; 1001 :                     }
; 1002 :                     while (copy--)
; 1003 :                         state->lens[state->have++] = (unsigned short)len;

  00dc0	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00dc3	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00dc8	8b 79 6c	 mov	 edi, DWORD PTR [ecx+108]
  00dcb	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00dce	89 7d c4	 mov	 DWORD PTR $T2[ebp], edi
  00dd1	89 79 6c	 mov	 DWORD PTR [ecx+108], edi
  00dd4	83 eb 01	 sub	 ebx, 1
  00dd7	75 e7		 jne	 SHORT $LL238@inflate
  00dd9	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  00ddc	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN971@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00ddf	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00de2	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00de5	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00de8	39 45 c4	 cmp	 DWORD PTR $T2[ebp], eax
  00deb	0f 82 af fd ff
	ff		 jb	 $LL185@inflate

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  00df1	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00df4	eb 19		 jmp	 SHORT $LN186@inflate
$LN567@inflate:

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  00df6	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00df9	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00e00	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00e07	e9 02 03 00 00	 jmp	 $LN8@inflate
$LN936@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00e0c	8b 45 d4	 mov	 eax, DWORD PTR $T13[ebp]
$LN186@inflate:

; 1004 :                 }
; 1005 :             }
; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  00e0f	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  00e14	0f 84 f4 02 00
	00		 je	 $LN8@inflate

; 1009 : 
; 1010 :             /* check for end-of-block code (better have one) */
; 1011 :             if (state->lens[256] == 0) {

  00e1a	66 83 b9 74 02
	00 00 00	 cmp	 WORD PTR [ecx+628], 0
  00e22	75 16		 jne	 SHORT $LN445@inflate

; 1012 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00e24	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e27	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
  00e2e	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00e35	e9 d4 02 00 00	 jmp	 $LN8@inflate
$LN445@inflate:

; 1013 :                 state->mode = BAD;
; 1014 :                 break;
; 1015 :             }
; 1016 : 
; 1017 :             /* build code tables -- note: do not change the lenbits or distbits
; 1018 :                values here (9 and 6) without reading the comments in inftrees.h
; 1019 :                concerning the ENOUGH constants, which depend on those values */
; 1020 :             state->next = state->codes;

  00e3a	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]

; 1021 :             state->lencode = (const code FAR *)(state->next);
; 1022 :             state->lenbits = 9;

  00e3d	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9
  00e44	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  00e4a	89 55 c0	 mov	 DWORD PTR tv5566[ebp], edx

; 1023 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00e4d	8d b9 f4 02 00
	00		 lea	 edi, DWORD PTR [ecx+756]
  00e53	89 02		 mov	 DWORD PTR [edx], eax
  00e55	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00e58	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00e5b	57		 push	 edi
  00e5c	50		 push	 eax
  00e5d	52		 push	 edx
  00e5e	ff 71 64	 push	 DWORD PTR [ecx+100]
  00e61	8d 51 74	 lea	 edx, DWORD PTR [ecx+116]
  00e64	89 7d c4	 mov	 DWORD PTR tv5561[ebp], edi
  00e67	b9 01 00 00 00	 mov	 ecx, 1
  00e6c	e8 00 00 00 00	 call	 _inflate_table

; 1024 :                                 &(state->lenbits), state->work);
; 1025 :             if (ret) {

  00e71	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00e74	83 c4 10	 add	 esp, 16			; 00000010H
  00e77	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e7a	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax
  00e7d	85 c0		 test	 eax, eax
  00e7f	74 19		 je	 SHORT $LN446@inflate

; 1026 :                 strm->msg = (char *)"invalid literal/lengths set";

  00e81	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1027 :                 state->mode = BAD;
; 1028 :                 break;

  00e84	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00e87	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  00e8e	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00e95	e9 74 02 00 00	 jmp	 $LN8@inflate
$LN446@inflate:

; 1029 :             }
; 1030 :             state->distcode = (const code FAR *)(state->next);

  00e9a	8b 55 c0	 mov	 edx, DWORD PTR tv5566[ebp]

; 1031 :             state->distbits = 6;
; 1032 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00e9d	ff 75 c4	 push	 DWORD PTR tv5561[ebp]
  00ea0	c7 41 5c 06 00
	00 00		 mov	 DWORD PTR [ecx+92], 6
  00ea7	8b 02		 mov	 eax, DWORD PTR [edx]
  00ea9	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00eac	8d 41 5c	 lea	 eax, DWORD PTR [ecx+92]
  00eaf	50		 push	 eax
  00eb0	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00eb3	52		 push	 edx
  00eb4	ff 71 68	 push	 DWORD PTR [ecx+104]
  00eb7	83 c1 74	 add	 ecx, 116		; 00000074H
  00eba	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00ebd	b9 02 00 00 00	 mov	 ecx, 2
  00ec2	e8 00 00 00 00	 call	 _inflate_table

; 1033 :                             &(state->next), &(state->distbits), state->work);
; 1034 :             if (ret) {

  00ec7	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00eca	83 c4 10	 add	 esp, 16			; 00000010H
  00ecd	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax
  00ed0	85 c0		 test	 eax, eax
  00ed2	74 19		 je	 SHORT $LN447@inflate

; 1035 :                 strm->msg = (char *)"invalid distances set";

  00ed4	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1036 :                 state->mode = BAD;
; 1037 :                 break;

  00ed7	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00eda	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  00ee1	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00ee8	e9 21 02 00 00	 jmp	 $LN8@inflate
$LN447@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;
; 1041 :             if (flush == Z_TREES) goto inf_leave;

  00eed	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  00ef0	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  00ef7	83 fa 06	 cmp	 edx, 6
  00efa	0f 84 dd 06 00
	00		 je	 $LN906@inflate
  00f00	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN448@inflate:

; 1042 :         case LEN_:
; 1043 :             state->mode = LEN;

  00f03	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
$LN450@inflate:

; 1044 :         case LEN:
; 1045 :             if (have >= 6 && left >= 258) {

  00f0a	83 fb 06	 cmp	 ebx, 6
  00f0d	72 77		 jb	 SHORT $LN451@inflate
  00f0f	81 7d e0 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00f16	72 6e		 jb	 SHORT $LN451@inflate

; 1046 :                 RESTORE();

  00f18	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00f1b	8b 7d dc	 mov	 edi, DWORD PTR _put$1$[ebp]

; 1047 :                 inflate_fast(strm, out);

  00f1e	ff 75 d8	 push	 DWORD PTR _out$1$[ebp]
  00f21	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00f24	8b 7d e0	 mov	 edi, DWORD PTR _left$1$[ebp]
  00f27	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00f2a	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00f2d	89 38		 mov	 DWORD PTR [eax], edi
  00f2f	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00f32	50		 push	 eax
  00f33	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  00f36	89 71 40	 mov	 DWORD PTR [ecx+64], esi
  00f39	e8 00 00 00 00	 call	 _inflate_fast

; 1048 :                 LOAD();

  00f3e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00f41	83 c4 08	 add	 esp, 8
  00f44	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00f47	8b 38		 mov	 edi, DWORD PTR [eax]
  00f49	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00f4c	89 4d dc	 mov	 DWORD PTR _put$1$[ebp], ecx
  00f4f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00f52	89 4d e0	 mov	 DWORD PTR _left$1$[ebp], ecx
  00f55	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00f58	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00f5b	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx

; 1049 :                 if (state->mode == TYPE)

  00f5e	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  00f65	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00f68	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00f6b	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00f6e	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00f71	0f 85 97 01 00
	00		 jne	 $LN8@inflate

; 1050 :                     state->back = -1;

  00f77	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 1051 :                 break;

  00f81	e9 88 01 00 00	 jmp	 $LN8@inflate
$LN451@inflate:

; 1052 :             }
; 1053 :             state->back = 0;

  00f86	c7 81 c8 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7112], 0

; 1054 :             for (;;) {
; 1055 :                 here = state->lencode[BITS(state->lenbits)];

  00f90	b8 01 00 00 00	 mov	 eax, 1
  00f95	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00f98	d3 e0		 shl	 eax, cl
  00f9a	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00f9d	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00fa0	89 4d c0	 mov	 DWORD PTR tv5514[ebp], ecx
  00fa3	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00fa6	89 45 d4	 mov	 DWORD PTR tv5559[ebp], eax
  00fa9	8b c1		 mov	 eax, ecx
  00fab	8b 4d d4	 mov	 ecx, DWORD PTR tv5559[ebp]
  00fae	23 c2		 and	 eax, edx
  00fb0	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00fb3	8b c8		 mov	 ecx, eax
  00fb5	c1 e9 08	 shr	 ecx, 8
  00fb8	0f b6 c9	 movzx	 ecx, cl

; 1056 :                 if ((unsigned)(here.bits) <= bits) break;

  00fbb	3b ce		 cmp	 ecx, esi
  00fbd	76 37		 jbe	 SHORT $LN569@inflate
  00fbf	90		 npad	 1
$LL246@inflate:

; 1057 :                 PULLBYTE();

  00fc0	85 db		 test	 ebx, ebx
  00fc2	0f 84 3a 06 00
	00		 je	 $LN930@inflate
  00fc8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00fcb	8b ce		 mov	 ecx, esi
  00fcd	d3 e0		 shl	 eax, cl
  00fcf	4b		 dec	 ebx
  00fd0	8b 4d d4	 mov	 ecx, DWORD PTR tv5559[ebp]
  00fd3	03 d0		 add	 edx, eax
  00fd5	8b 45 c0	 mov	 eax, DWORD PTR tv5514[ebp]
  00fd8	47		 inc	 edi
  00fd9	23 c2		 and	 eax, edx
  00fdb	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00fde	83 c6 08	 add	 esi, 8
  00fe1	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00fe4	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00fe7	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00fea	8b c8		 mov	 ecx, eax
  00fec	c1 e9 08	 shr	 ecx, 8
  00fef	0f b6 c9	 movzx	 ecx, cl
  00ff2	3b ce		 cmp	 ecx, esi
  00ff4	77 ca		 ja	 SHORT $LL246@inflate
$LN569@inflate:

; 1058 :             }
; 1059 :             if (here.op && (here.op & 0xf0) == 0) {

  00ff6	84 c0		 test	 al, al
  00ff8	0f 84 ae 00 00
	00		 je	 $LN934@inflate
  00ffe	a8 f0		 test	 al, 240			; 000000f0H
  01000	0f 85 a6 00 00
	00		 jne	 $LN934@inflate

; 1060 :                 last = here;

  01006	8b c8		 mov	 ecx, eax

; 1061 :                 for (;;) {
; 1062 :                     here = state->lencode[last.val +

  01008	bf 01 00 00 00	 mov	 edi, 1
  0100d	c1 e9 08	 shr	 ecx, 8
  01010	8b d0		 mov	 edx, eax
  01012	0f b6 d9	 movzx	 ebx, cl
  01015	0f b6 c8	 movzx	 ecx, al
  01018	03 cb		 add	 ecx, ebx
  0101a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0101d	d3 e7		 shl	 edi, cl
  0101f	8b cb		 mov	 ecx, ebx
  01021	4f		 dec	 edi
  01022	89 55 cc	 mov	 DWORD PTR _last$[ebp], edx
  01025	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  01028	d3 ef		 shr	 edi, cl
  0102a	8b 4d d4	 mov	 ecx, DWORD PTR tv5559[ebp]
  0102d	03 f8		 add	 edi, eax
  0102f	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
  01032	8b c8		 mov	 ecx, eax
  01034	c1 e9 08	 shr	 ecx, 8

; 1063 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1064 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01037	0f b6 c9	 movzx	 ecx, cl
  0103a	03 cb		 add	 ecx, ebx
  0103c	3b ce		 cmp	 ecx, esi
  0103e	76 54		 jbe	 SHORT $LN260@inflate
$LL252@inflate:

; 1065 :                     PULLBYTE();

  01040	8b 45 f0	 mov	 eax, DWORD PTR _have$1$[ebp]
  01043	85 c0		 test	 eax, eax
  01045	0f 84 ba 05 00
	00		 je	 $LN942@inflate
  0104b	8b 5d ec	 mov	 ebx, DWORD PTR _next$1$[ebp]
  0104e	48		 dec	 eax
  0104f	89 45 f0	 mov	 DWORD PTR _have$1$[ebp], eax
  01052	8b ce		 mov	 ecx, esi
  01054	bf 01 00 00 00	 mov	 edi, 1
  01059	83 c6 08	 add	 esi, 8
  0105c	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0105f	43		 inc	 ebx
  01060	d3 e0		 shl	 eax, cl
  01062	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  01065	0f b7 45 ce	 movzx	 eax, WORD PTR _last$[ebp+2]
  01069	89 5d ec	 mov	 DWORD PTR _next$1$[ebp], ebx
  0106c	0f b6 de	 movzx	 ebx, dh
  0106f	0f b6 ca	 movzx	 ecx, dl
  01072	03 cb		 add	 ecx, ebx
  01074	d3 e7		 shl	 edi, cl
  01076	8b cb		 mov	 ecx, ebx
  01078	4f		 dec	 edi
  01079	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  0107c	d3 ef		 shr	 edi, cl
  0107e	03 f8		 add	 edi, eax
  01080	8b 45 d4	 mov	 eax, DWORD PTR tv5559[ebp]
  01083	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  01086	8b c8		 mov	 ecx, eax
  01088	c1 e9 08	 shr	 ecx, 8
  0108b	0f b6 c9	 movzx	 ecx, cl
  0108e	03 cb		 add	 ecx, ebx
  01090	3b ce		 cmp	 ecx, esi
  01092	77 ac		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1066 :                 }
; 1067 :                 DROPBITS(last.bits);
; 1068 :                 state->back += last.bits;

  01094	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  01097	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  0109a	0f b6 ce	 movzx	 ecx, dh
  0109d	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  010a0	d3 ea		 shr	 edx, cl
  010a2	2b f1		 sub	 esi, ecx
  010a4	89 8f c8 1b 00
	00		 mov	 DWORD PTR [edi+7112], ecx
  010aa	eb 03		 jmp	 SHORT $LN263@inflate
$LN934@inflate:

; 1069 :             }
; 1070 :             DROPBITS(here.bits);

  010ac	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
$LN263@inflate:
  010af	8b c8		 mov	 ecx, eax
  010b1	c1 e9 08	 shr	 ecx, 8
  010b4	0f b6 c9	 movzx	 ecx, cl

; 1071 :             state->back += here.bits;

  010b7	01 8f c8 1b 00
	00		 add	 DWORD PTR [edi+7112], ecx
  010bd	2b f1		 sub	 esi, ecx
  010bf	d3 ea		 shr	 edx, cl

; 1072 :             state->length = (unsigned)here.val;

  010c1	8b c8		 mov	 ecx, eax
  010c3	c1 e9 10	 shr	 ecx, 16			; 00000010H
  010c6	89 4f 44	 mov	 DWORD PTR [edi+68], ecx

; 1073 :             if ((int)(here.op) == 0) {

  010c9	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  010cc	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  010cf	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  010d2	84 c0		 test	 al, al
  010d4	75 09		 jne	 SHORT $LN458@inflate

; 1074 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1075 :                         "inflate:         literal '%c'\n" :
; 1076 :                         "inflate:         literal 0x%02x\n", here.val));
; 1077 :                 state->mode = LIT;

  010d6	c7 41 04 4d 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16205 ; 00003f4dH

; 1078 :                 break;

  010dd	eb 2c		 jmp	 SHORT $LN931@inflate
$LN458@inflate:

; 1079 :             }
; 1080 :             if (here.op & 32) {

  010df	a8 20		 test	 al, 32			; 00000020H
  010e1	74 13		 je	 SHORT $LN459@inflate

; 1081 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1082 :                 state->back = -1;

  010e3	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 1083 :                 state->mode = TYPE;

  010ed	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 1084 :                 break;

  010f4	eb 15		 jmp	 SHORT $LN931@inflate
$LN459@inflate:

; 1085 :             }
; 1086 :             if (here.op & 64) {

  010f6	a8 40		 test	 al, 64			; 00000040H
  010f8	74 36		 je	 SHORT $LN460@inflate

; 1087 :                 strm->msg = (char *)"invalid literal/length code";

  010fa	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  010fd	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
$LN975@inflate:

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  01104	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN931@inflate:
  0110b	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
$LN8@inflate:
  0110e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01111	89 45 d4	 mov	 DWORD PTR $T13[ebp], eax
  01114	05 cc c0 ff ff	 add	 eax, -16180		; ffffc0ccH
  01119	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0111c	0f 86 7e ef ff
	ff		 jbe	 $LL5@inflate
$LN333@inflate:
  01122	5f		 pop	 edi

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  01123	5e		 pop	 esi
  01124	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  01129	5b		 pop	 ebx
  0112a	8b e5		 mov	 esp, ebp
  0112c	5d		 pop	 ebp
  0112d	c2 08 00	 ret	 8
$LN460@inflate:

; 1088 :                 state->mode = BAD;
; 1089 :                 break;
; 1090 :             }
; 1091 :             state->extra = (unsigned)(here.op) & 15;

  01130	0f b6 c0	 movzx	 eax, al
  01133	83 e0 0f	 and	 eax, 15			; 0000000fH

; 1092 :             state->mode = LENEXT;

  01136	c7 41 04 49 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16201 ; 00003f49H
  0113d	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
$LN461@inflate:

; 1093 :         case LENEXT:
; 1094 :             if (state->extra) {

  01140	8b 79 4c	 mov	 edi, DWORD PTR [ecx+76]
  01143	85 ff		 test	 edi, edi
  01145	74 51		 je	 SHORT $LN752@inflate

; 1095 :                 NEEDBITS(state->extra);

  01147	3b f7		 cmp	 esi, edi
  01149	73 29		 jae	 SHORT $LN264@inflate
  0114b	8b 55 ec	 mov	 edx, DWORD PTR _next$1$[ebp]
  0114e	66 90		 npad	 2
$LL267@inflate:
  01150	85 db		 test	 ebx, ebx
  01152	0f 84 aa 04 00
	00		 je	 $LN930@inflate
  01158	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0115b	8b ce		 mov	 ecx, esi
  0115d	d3 e0		 shl	 eax, cl
  0115f	4b		 dec	 ebx
  01160	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  01163	42		 inc	 edx
  01164	83 c6 08	 add	 esi, 8
  01167	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0116a	89 55 ec	 mov	 DWORD PTR _next$1$[ebp], edx
  0116d	3b f7		 cmp	 esi, edi
  0116f	72 df		 jb	 SHORT $LL267@inflate
  01171	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN264@inflate:

; 1096 :                 state->length += BITS(state->extra);

  01174	8b cf		 mov	 ecx, edi
  01176	b8 01 00 00 00	 mov	 eax, 1
  0117b	d3 e0		 shl	 eax, cl

; 1097 :                 DROPBITS(state->extra);

  0117d	2b f7		 sub	 esi, edi
  0117f	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01182	48		 dec	 eax
  01183	23 c2		 and	 eax, edx
  01185	01 41 44	 add	 DWORD PTR [ecx+68], eax
  01188	8b cf		 mov	 ecx, edi
  0118a	d3 ea		 shr	 edx, cl

; 1098 :                 state->back += state->extra;

  0118c	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0118f	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01192	01 b9 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], edi
$LN752@inflate:

; 1099 :             }
; 1100 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1101 :             state->was = state->length;

  01198	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0119b	89 81 cc 1b 00
	00		 mov	 DWORD PTR [ecx+7116], eax

; 1102 :             state->mode = DIST;

  011a1	c7 41 04 4a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16202 ; 00003f4aH
$LN464@inflate:

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  011a8	8b 49 5c	 mov	 ecx, DWORD PTR [ecx+92]
  011ab	b8 01 00 00 00	 mov	 eax, 1
  011b0	d3 e0		 shl	 eax, cl
  011b2	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  011b5	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  011b8	89 4d c0	 mov	 DWORD PTR tv5504[ebp], ecx
  011bb	23 ca		 and	 ecx, edx
  011bd	8b 78 54	 mov	 edi, DWORD PTR [eax+84]
  011c0	89 7d c4	 mov	 DWORD PTR tv5534[ebp], edi
  011c3	8b 04 8f	 mov	 eax, DWORD PTR [edi+ecx*4]
  011c6	8b c8		 mov	 ecx, eax
  011c8	c1 e9 08	 shr	 ecx, 8
  011cb	0f b6 c9	 movzx	 ecx, cl

; 1106 :                 if ((unsigned)(here.bits) <= bits) break;

  011ce	3b ce		 cmp	 ecx, esi
  011d0	76 3c		 jbe	 SHORT $LN574@inflate
  011d2	8b 55 ec	 mov	 edx, DWORD PTR _next$1$[ebp]
$LL275@inflate:

; 1107 :                 PULLBYTE();

  011d5	85 db		 test	 ebx, ebx
  011d7	0f 84 25 04 00
	00		 je	 $LN930@inflate
  011dd	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  011e0	8b ce		 mov	 ecx, esi
  011e2	d3 e0		 shl	 eax, cl
  011e4	4b		 dec	 ebx
  011e5	8b 4d f8	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  011e8	42		 inc	 edx
  011e9	03 c8		 add	 ecx, eax
  011eb	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  011ee	8b 45 c0	 mov	 eax, DWORD PTR tv5504[ebp]
  011f1	83 c6 08	 add	 esi, 8
  011f4	23 c1		 and	 eax, ecx
  011f6	89 4d f8	 mov	 DWORD PTR _hold$1$[ebp], ecx
  011f9	89 55 ec	 mov	 DWORD PTR _next$1$[ebp], edx
  011fc	8b 04 87	 mov	 eax, DWORD PTR [edi+eax*4]
  011ff	8b c8		 mov	 ecx, eax
  01201	c1 e9 08	 shr	 ecx, 8
  01204	0f b6 c9	 movzx	 ecx, cl
  01207	3b ce		 cmp	 ecx, esi
  01209	77 ca		 ja	 SHORT $LL275@inflate
  0120b	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN574@inflate:

; 1108 :             }
; 1109 :             if ((here.op & 0xf0) == 0) {

  0120e	a8 f0		 test	 al, 240			; 000000f0H
  01210	0f 85 a3 00 00
	00		 jne	 $LN935@inflate

; 1110 :                 last = here;

  01216	8b c8		 mov	 ecx, eax

; 1111 :                 for (;;) {
; 1112 :                     here = state->distcode[last.val +

  01218	bf 01 00 00 00	 mov	 edi, 1
  0121d	c1 e9 08	 shr	 ecx, 8
  01220	8b d0		 mov	 edx, eax
  01222	0f b6 d9	 movzx	 ebx, cl
  01225	0f b6 c8	 movzx	 ecx, al
  01228	03 cb		 add	 ecx, ebx
  0122a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0122d	d3 e7		 shl	 edi, cl
  0122f	8b cb		 mov	 ecx, ebx
  01231	4f		 dec	 edi
  01232	89 55 cc	 mov	 DWORD PTR _last$[ebp], edx
  01235	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  01238	d3 ef		 shr	 edi, cl
  0123a	8b 4d c4	 mov	 ecx, DWORD PTR tv5534[ebp]
  0123d	03 f8		 add	 edi, eax
  0123f	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
  01242	8b c8		 mov	 ecx, eax
  01244	c1 e9 08	 shr	 ecx, 8

; 1113 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1114 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01247	0f b6 c9	 movzx	 ecx, cl
  0124a	03 cb		 add	 ecx, ebx
  0124c	3b ce		 cmp	 ecx, esi
  0124e	76 54		 jbe	 SHORT $LN289@inflate
$LL281@inflate:

; 1115 :                     PULLBYTE();

  01250	8b 45 f0	 mov	 eax, DWORD PTR _have$1$[ebp]
  01253	85 c0		 test	 eax, eax
  01255	0f 84 aa 03 00
	00		 je	 $LN942@inflate
  0125b	8b 5d ec	 mov	 ebx, DWORD PTR _next$1$[ebp]
  0125e	48		 dec	 eax
  0125f	89 45 f0	 mov	 DWORD PTR _have$1$[ebp], eax
  01262	8b ce		 mov	 ecx, esi
  01264	bf 01 00 00 00	 mov	 edi, 1
  01269	83 c6 08	 add	 esi, 8
  0126c	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0126f	43		 inc	 ebx
  01270	d3 e0		 shl	 eax, cl
  01272	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  01275	0f b7 45 ce	 movzx	 eax, WORD PTR _last$[ebp+2]
  01279	89 5d ec	 mov	 DWORD PTR _next$1$[ebp], ebx
  0127c	0f b6 de	 movzx	 ebx, dh
  0127f	0f b6 ca	 movzx	 ecx, dl
  01282	03 cb		 add	 ecx, ebx
  01284	d3 e7		 shl	 edi, cl
  01286	8b cb		 mov	 ecx, ebx
  01288	4f		 dec	 edi
  01289	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  0128c	d3 ef		 shr	 edi, cl
  0128e	03 f8		 add	 edi, eax
  01290	8b 45 c4	 mov	 eax, DWORD PTR tv5534[ebp]
  01293	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  01296	8b c8		 mov	 ecx, eax
  01298	c1 e9 08	 shr	 ecx, 8
  0129b	0f b6 c9	 movzx	 ecx, cl
  0129e	03 cb		 add	 ecx, ebx
  012a0	3b ce		 cmp	 ecx, esi
  012a2	77 ac		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1116 :                 }
; 1117 :                 DROPBITS(last.bits);
; 1118 :                 state->back += last.bits;

  012a4	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  012a7	0f b6 ce	 movzx	 ecx, dh
  012aa	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  012ad	2b f1		 sub	 esi, ecx
  012af	d3 ea		 shr	 edx, cl
  012b1	01 8b c8 1b 00
	00		 add	 DWORD PTR [ebx+7112], ecx
  012b7	eb 03		 jmp	 SHORT $LN292@inflate
$LN935@inflate:

; 1108 :             }
; 1109 :             if ((here.op & 0xf0) == 0) {

  012b9	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
$LN292@inflate:

; 1119 :             }
; 1120 :             DROPBITS(here.bits);

  012bc	8b c8		 mov	 ecx, eax
  012be	c1 e9 08	 shr	 ecx, 8
  012c1	0f b6 c9	 movzx	 ecx, cl

; 1121 :             state->back += here.bits;

  012c4	01 8b c8 1b 00
	00		 add	 DWORD PTR [ebx+7112], ecx
  012ca	2b f1		 sub	 esi, ecx
  012cc	d3 ea		 shr	 edx, cl
  012ce	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  012d1	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 1122 :             if (here.op & 64) {

  012d4	a8 40		 test	 al, 64			; 00000040H
  012d6	74 15		 je	 SHORT $LN470@inflate

; 1123 :                 strm->msg = (char *)"invalid distance code";

  012d8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1124 :                 state->mode = BAD;

  012db	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 1125 :                 break;

  012de	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  012e1	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  012e8	e9 17 fe ff ff	 jmp	 $LN975@inflate
$LN470@inflate:

; 1126 :             }
; 1127 :             state->offset = (unsigned)here.val;

  012ed	8b c8		 mov	 ecx, eax

; 1128 :             state->extra = (unsigned)(here.op) & 15;

  012ef	0f b6 c0	 movzx	 eax, al
  012f2	c1 e9 10	 shr	 ecx, 16			; 00000010H
  012f5	83 e0 0f	 and	 eax, 15			; 0000000fH
  012f8	89 4b 48	 mov	 DWORD PTR [ebx+72], ecx
  012fb	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  012fe	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01301	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1129 :             state->mode = DISTEXT;

  01304	c7 41 04 4b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16203 ; 00003f4bH
$LN471@inflate:

; 1130 :         case DISTEXT:
; 1131 :             if (state->extra) {

  0130b	8b 79 4c	 mov	 edi, DWORD PTR [ecx+76]
  0130e	85 ff		 test	 edi, edi
  01310	74 59		 je	 SHORT $LN754@inflate

; 1132 :                 NEEDBITS(state->extra);

  01312	3b f7		 cmp	 esi, edi
  01314	73 2e		 jae	 SHORT $LN293@inflate
  01316	8b 55 ec	 mov	 edx, DWORD PTR _next$1$[ebp]
  01319	0f 1f 80 00 00
	00 00		 npad	 7
$LL296@inflate:
  01320	85 db		 test	 ebx, ebx
  01322	0f 84 da 02 00
	00		 je	 $LN930@inflate
  01328	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0132b	8b ce		 mov	 ecx, esi
  0132d	d3 e0		 shl	 eax, cl
  0132f	4b		 dec	 ebx
  01330	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  01333	42		 inc	 edx
  01334	83 c6 08	 add	 esi, 8
  01337	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0133a	89 55 ec	 mov	 DWORD PTR _next$1$[ebp], edx
  0133d	3b f7		 cmp	 esi, edi
  0133f	72 df		 jb	 SHORT $LL296@inflate
  01341	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN293@inflate:

; 1133 :                 state->offset += BITS(state->extra);

  01344	8b cf		 mov	 ecx, edi
  01346	b8 01 00 00 00	 mov	 eax, 1
  0134b	d3 e0		 shl	 eax, cl

; 1134 :                 DROPBITS(state->extra);

  0134d	2b f7		 sub	 esi, edi
  0134f	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01352	48		 dec	 eax
  01353	23 c2		 and	 eax, edx
  01355	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  01358	01 41 48	 add	 DWORD PTR [ecx+72], eax
  0135b	8b cf		 mov	 ecx, edi
  0135d	d3 ea		 shr	 edx, cl

; 1135 :                 state->back += state->extra;

  0135f	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01362	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01365	01 b9 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], edi
$LN754@inflate:

; 1136 :             }
; 1137 : #ifdef INFLATE_STRICT
; 1138 :             if (state->offset > state->dmax) {
; 1139 :                 strm->msg = (char *)"invalid distance too far back";
; 1140 :                 state->mode = BAD;
; 1141 :                 break;
; 1142 :             }
; 1143 : #endif
; 1144 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1145 :             state->mode = MATCH;

  0136b	c7 41 04 4c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16204 ; 00003f4cH
$LN474@inflate:

; 1146 :         case MATCH:
; 1147 :             if (left == 0) goto inf_leave;

  01372	8b 7d e0	 mov	 edi, DWORD PTR _left$1$[ebp]
  01375	85 ff		 test	 edi, edi
  01377	0f 84 85 02 00
	00		 je	 $LN930@inflate

; 1148 :             copy = out - left;

  0137d	8b 45 d8	 mov	 eax, DWORD PTR _out$1$[ebp]
  01380	2b c7		 sub	 eax, edi

; 1149 :             if (state->offset > copy) {         /* copy from window */

  01382	8b 79 48	 mov	 edi, DWORD PTR [ecx+72]
  01385	3b f8		 cmp	 edi, eax
  01387	76 4b		 jbe	 SHORT $LN476@inflate

; 1150 :                 copy = state->offset - copy;

  01389	2b f8		 sub	 edi, eax

; 1151 :                 if (copy > state->whave) {

  0138b	3b 79 30	 cmp	 edi, DWORD PTR [ecx+48]
  0138e	76 18		 jbe	 SHORT $LN479@inflate

; 1152 :                     if (state->sane) {

  01390	83 b9 c4 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7108], 0
  01397	74 0f		 je	 SHORT $LN479@inflate

; 1153 :                         strm->msg = (char *)"invalid distance too far back";

  01399	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0139c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 1154 :                         state->mode = BAD;
; 1155 :                         break;

  013a3	e9 5c fd ff ff	 jmp	 $LN975@inflate
$LN479@inflate:

; 1156 :                     }
; 1157 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1158 :                     Trace((stderr, "inflate.c too far\n"));
; 1159 :                     copy -= state->whave;
; 1160 :                     if (copy > state->length) copy = state->length;
; 1161 :                     if (copy > left) copy = left;
; 1162 :                     left -= copy;
; 1163 :                     state->length -= copy;
; 1164 :                     do {
; 1165 :                         *put++ = 0;
; 1166 :                     } while (--copy);
; 1167 :                     if (state->length == 0) state->mode = LEN;
; 1168 :                     break;
; 1169 : #endif
; 1170 :                 }
; 1171 :                 if (copy > state->wnext) {

  013a8	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  013ab	3b fa		 cmp	 edi, edx
  013ad	76 0c		 jbe	 SHORT $LN480@inflate

; 1172 :                     copy -= state->wnext;
; 1173 :                     from = state->window + (state->wsize - copy);

  013af	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  013b2	2b fa		 sub	 edi, edx
  013b4	2b c7		 sub	 eax, edi
  013b6	03 41 38	 add	 eax, DWORD PTR [ecx+56]

; 1174 :                 }

  013b9	eb 07		 jmp	 SHORT $LN974@inflate
$LN480@inflate:

; 1175 :                 else
; 1176 :                     from = state->window + (state->wnext - copy);

  013bb	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  013be	2b c7		 sub	 eax, edi
  013c0	03 c2		 add	 eax, edx
$LN974@inflate:

; 1177 :                 if (copy > state->length) copy = state->length;

  013c2	89 45 cc	 mov	 DWORD PTR _from$1$[ebp], eax
  013c5	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 1178 :             }

  013c8	3b f8		 cmp	 edi, eax
  013ca	8b d0		 mov	 edx, eax
  013cc	0f 46 d7	 cmovbe	 edx, edi
  013cf	89 55 c4	 mov	 DWORD PTR _copy$7$[ebp], edx
  013d2	eb 0e		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1179 :             else {                              /* copy from output */
; 1180 :                 from = put - state->offset;

  013d4	8b 45 dc	 mov	 eax, DWORD PTR _put$1$[ebp]
  013d7	2b c7		 sub	 eax, edi
  013d9	89 45 cc	 mov	 DWORD PTR _from$1$[ebp], eax

; 1181 :                 copy = state->length;

  013dc	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  013df	89 45 c4	 mov	 DWORD PTR _copy$7$[ebp], eax
$LN477@inflate:

; 1182 :             }
; 1183 :             if (copy > left) copy = left;
; 1184 :             left -= copy;

  013e2	8b 55 e0	 mov	 edx, DWORD PTR _left$1$[ebp]
  013e5	8b fa		 mov	 edi, edx
  013e7	39 55 c4	 cmp	 DWORD PTR _copy$7$[ebp], edx

; 1185 :             state->length -= copy;

  013ea	8b 5d cc	 mov	 ebx, DWORD PTR _from$1$[ebp]
  013ed	0f 46 7d c4	 cmovbe	 edi, DWORD PTR _copy$7$[ebp]
  013f1	2b d7		 sub	 edx, edi
  013f3	2b c7		 sub	 eax, edi
  013f5	89 55 e0	 mov	 DWORD PTR _left$1$[ebp], edx
  013f8	8b 55 dc	 mov	 edx, DWORD PTR _put$1$[ebp]
  013fb	2b da		 sub	 ebx, edx
  013fd	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LL306@inflate:

; 1186 :             do {
; 1187 :                 *put++ = *from++;

  01400	8a 04 13	 mov	 al, BYTE PTR [ebx+edx]
  01403	88 02		 mov	 BYTE PTR [edx], al
  01405	42		 inc	 edx

; 1188 :             } while (--copy);

  01406	83 ef 01	 sub	 edi, 1
  01409	75 f5		 jne	 SHORT $LL306@inflate

; 1189 :             if (state->length == 0) state->mode = LEN;

  0140b	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  0140e	89 55 dc	 mov	 DWORD PTR _put$1$[ebp], edx
  01411	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01414	39 79 44	 cmp	 DWORD PTR [ecx+68], edi
  01417	0f 85 ee fc ff
	ff		 jne	 $LN931@inflate
  0141d	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H

; 1190 :             break;

  01424	e9 e2 fc ff ff	 jmp	 $LN931@inflate
$LN485@inflate:

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  01429	83 7d e0 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  0142d	0f 84 cf 01 00
	00		 je	 $LN930@inflate

; 1193 :             *put++ = (unsigned char)(state->length);

  01433	8b 55 dc	 mov	 edx, DWORD PTR _put$1$[ebp]
  01436	8a 41 44	 mov	 al, BYTE PTR [ecx+68]
  01439	ff 45 dc	 inc	 DWORD PTR _put$1$[ebp]

; 1194 :             left--;

  0143c	ff 4d e0	 dec	 DWORD PTR _left$1$[ebp]
  0143f	88 02		 mov	 BYTE PTR [edx], al

; 1195 :             state->mode = LEN;
; 1196 :             break;

  01441	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01444	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
  0144b	e9 be fc ff ff	 jmp	 $LN8@inflate
$LN487@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  01450	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  01454	0f 84 ec 00 00
	00		 je	 $LN316@inflate

; 1199 :                 NEEDBITS(32);

  0145a	83 fe 20	 cmp	 esi, 32			; 00000020H
  0145d	73 2b		 jae	 SHORT $LN307@inflate
  0145f	90		 npad	 1
$LL310@inflate:
  01460	85 db		 test	 ebx, ebx
  01462	0f 84 9a 01 00
	00		 je	 $LN930@inflate
  01468	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0146b	8b ce		 mov	 ecx, esi
  0146d	d3 e0		 shl	 eax, cl
  0146f	83 c6 08	 add	 esi, 8
  01472	4b		 dec	 ebx
  01473	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  01476	03 d0		 add	 edx, eax
  01478	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0147b	47		 inc	 edi
  0147c	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0147f	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  01482	83 fe 20	 cmp	 esi, 32			; 00000020H
  01485	72 d9		 jb	 SHORT $LL310@inflate
  01487	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN307@inflate:

; 1200 :                 out -= left;

  0148a	8b 45 e0	 mov	 eax, DWORD PTR _left$1$[ebp]
  0148d	29 45 d8	 sub	 DWORD PTR _out$1$[ebp], eax

; 1201 :                 strm->total_out += out;

  01490	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01493	8b 7d d8	 mov	 edi, DWORD PTR _out$1$[ebp]
  01496	01 78 14	 add	 DWORD PTR [eax+20], edi

; 1202 :                 state->total += out;

  01499	8b c7		 mov	 eax, edi
  0149b	01 41 20	 add	 DWORD PTR [ecx+32], eax

; 1203 :                 if ((state->wrap & 4) && out)

  0149e	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  014a1	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  014a4	a8 04		 test	 al, 4
  014a6	74 38		 je	 SHORT $LN490@inflate
  014a8	83 7d d8 00	 cmp	 DWORD PTR _out$1$[ebp], 0
  014ac	74 32		 je	 SHORT $LN490@inflate

; 1204 :                     strm->adler = state->check =

  014ae	8b 45 dc	 mov	 eax, DWORD PTR _put$1$[ebp]
  014b1	ff 75 d8	 push	 DWORD PTR _out$1$[ebp]
  014b4	2b 45 d8	 sub	 eax, DWORD PTR _out$1$[ebp]
  014b7	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  014bb	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  014be	50		 push	 eax
  014bf	52		 push	 edx
  014c0	74 07		 je	 SHORT $LN511@inflate
  014c2	e8 00 00 00 00	 call	 _crc32@12
  014c7	eb 05		 jmp	 SHORT $LN512@inflate
$LN511@inflate:
  014c9	e8 00 00 00 00	 call	 _adler32@12
$LN512@inflate:
  014ce	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  014d1	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  014d4	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  014d7	89 42 30	 mov	 DWORD PTR [edx+48], eax
  014da	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  014dd	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN490@inflate:

; 1205 :                         UPDATE(state->check, put - out, out);
; 1206 :                 out = left;

  014e0	8b 5d e0	 mov	 ebx, DWORD PTR _left$1$[ebp]
  014e3	89 5d d8	 mov	 DWORD PTR _out$1$[ebp], ebx

; 1207 :                 if ((state->wrap & 4) && (

  014e6	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  014e9	a8 04		 test	 al, 4
  014eb	74 4f		 je	 SHORT $LN317@inflate
  014ed	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  014f1	8b c2		 mov	 eax, edx
  014f3	75 2c		 jne	 SHORT $LN514@inflate
  014f5	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  014fa	89 45 d4	 mov	 DWORD PTR tv5680[ebp], eax
  014fd	8b c2		 mov	 eax, edx
  014ff	c1 e0 10	 shl	 eax, 16			; 00000010H
  01502	01 45 d4	 add	 DWORD PTR tv5680[ebp], eax
  01505	8b c2		 mov	 eax, edx
  01507	c1 65 d4 08	 shl	 DWORD PTR tv5680[ebp], 8
  0150b	c1 e8 08	 shr	 eax, 8
  0150e	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01513	01 45 d4	 add	 DWORD PTR tv5680[ebp], eax
  01516	8b c2		 mov	 eax, edx
  01518	c1 e8 18	 shr	 eax, 24			; 00000018H
  0151b	01 45 d4	 add	 DWORD PTR tv5680[ebp], eax
  0151e	8b 45 d4	 mov	 eax, DWORD PTR tv5680[ebp]
$LN514@inflate:
  01521	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  01524	74 16		 je	 SHORT $LN317@inflate

; 1208 : #ifdef GUNZIP
; 1209 :                      state->flags ? hold :
; 1210 : #endif
; 1211 :                      ZSWAP32(hold)) != state->check) {
; 1212 :                     strm->msg = (char *)"incorrect data check";

  01526	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01529	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
  01530	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  01537	e9 d2 fb ff ff	 jmp	 $LN8@inflate
$LN317@inflate:

; 1213 :                     state->mode = BAD;
; 1214 :                     break;
; 1215 :                 }
; 1216 :                 INITBITS();

  0153c	33 d2		 xor	 edx, edx
  0153e	33 f6		 xor	 esi, esi
  01540	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01543	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN316@inflate:

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  01546	c7 41 04 4f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16207 ; 00003f4fH
$LN492@inflate:

; 1221 :         case LENGTH:
; 1222 :             if (state->wrap && state->flags) {

  0154d	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  01551	0f 84 94 00 00
	00		 je	 $LN327@inflate
  01557	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0155b	0f 84 8a 00 00
	00		 je	 $LN327@inflate

; 1223 :                 NEEDBITS(32);

  01561	83 fe 20	 cmp	 esi, 32			; 00000020H
  01564	73 2a		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  01566	85 db		 test	 ebx, ebx
  01568	0f 84 94 00 00
	00		 je	 $LN930@inflate
  0156e	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  01571	8b ce		 mov	 ecx, esi
  01573	d3 e0		 shl	 eax, cl
  01575	83 c6 08	 add	 esi, 8
  01578	4b		 dec	 ebx
  01579	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0157c	03 d0		 add	 edx, eax
  0157e	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  01581	47		 inc	 edi
  01582	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01585	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  01588	83 fe 20	 cmp	 esi, 32			; 00000020H
  0158b	72 d9		 jb	 SHORT $LL321@inflate
  0158d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN318@inflate:

; 1224 :                 if (hold != (state->total & 0xffffffffUL)) {

  01590	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  01593	74 4d		 je	 SHORT $LN328@inflate

; 1225 :                     strm->msg = (char *)"incorrect length check";

  01595	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01598	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
  0159f	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  015a6	e9 63 fb ff ff	 jmp	 $LN8@inflate
$LN586@inflate:

; 844  :                 RESTORE();

  015ab	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  015ae	8b 4d dc	 mov	 ecx, DWORD PTR _put$1$[ebp]
  015b1	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  015b4	8b 4d e0	 mov	 ecx, DWORD PTR _left$1$[ebp]
  015b7	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  015ba	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  015bd	89 38		 mov	 DWORD PTR [eax], edi
  015bf	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 845  :                 return Z_NEED_DICT;

  015c2	b8 02 00 00 00	 mov	 eax, 2
  015c7	5f		 pop	 edi
  015c8	89 71 40	 mov	 DWORD PTR [ecx+64], esi

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  015cb	5e		 pop	 esi
  015cc	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  015cf	5b		 pop	 ebx
  015d0	8b e5		 mov	 esp, ebp
  015d2	5d		 pop	 ebp
  015d3	c2 08 00	 ret	 8
$LN587@inflate:

; 872  :                     DROPBITS(2);

  015d6	c1 6d f8 02	 shr	 DWORD PTR _hold$1$[ebp], 2
  015da	83 ee 03	 sub	 esi, 3
$LN906@inflate:

; 1239 :             goto inf_leave;
; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;
; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;
; 1245 :         }
; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  015dd	8b 45 f0	 mov	 eax, DWORD PTR _have$1$[ebp]
  015e0	eb 26		 jmp	 SHORT $inf_leave$981
$LN328@inflate:

; 1226 :                     state->mode = BAD;
; 1227 :                     break;
; 1228 :                 }
; 1229 :                 INITBITS();

  015e2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  015e9	33 f6		 xor	 esi, esi
$LN327@inflate:

; 1230 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1231 :             }
; 1232 : #endif
; 1233 :             state->mode = DONE;

  015eb	c7 41 04 50 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16208 ; 00003f50H
$LN496@inflate:

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;

  015f2	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1239 :             goto inf_leave;
; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;
; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;
; 1245 :         }
; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  015f9	eb 07		 jmp	 SHORT $LN930@inflate
$LN497@inflate:

; 1236 :             goto inf_leave;
; 1237 :         case BAD:
; 1238 :             ret = Z_DATA_ERROR;

  015fb	c7 45 d0 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH
$LN930@inflate:

; 1239 :             goto inf_leave;
; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;
; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;
; 1245 :         }
; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  01602	8b 45 f0	 mov	 eax, DWORD PTR _have$1$[ebp]
$LN942@inflate:
  01605	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
$inf_leave$981:
  01608	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  0160b	8b 4d dc	 mov	 ecx, DWORD PTR _put$1$[ebp]
  0160e	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  01611	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  01614	8b 4d e0	 mov	 ecx, DWORD PTR _left$1$[ebp]
  01617	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  0161a	8b 4d ec	 mov	 ecx, DWORD PTR _next$1$[ebp]
  0161d	89 47 04	 mov	 DWORD PTR [edi+4], eax
  01620	8b 45 f8	 mov	 eax, DWORD PTR _hold$1$[ebp]
  01623	89 0f		 mov	 DWORD PTR [edi], ecx

; 1255 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  01625	83 7b 2c 00	 cmp	 DWORD PTR [ebx+44], 0
  01629	89 73 40	 mov	 DWORD PTR [ebx+64], esi
  0162c	8b 75 d8	 mov	 esi, DWORD PTR _out$1$[ebp]
  0162f	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  01632	75 1b		 jne	 SHORT $LN502@inflate
  01634	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  01637	74 42		 je	 SHORT $LN503@inflate
  01639	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0163c	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  01641	7d 38		 jge	 SHORT $LN503@inflate
  01643	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  01648	7c 05		 jl	 SHORT $LN502@inflate
  0164a	83 fa 04	 cmp	 edx, 4
  0164d	74 2c		 je	 SHORT $LN503@inflate
$LN502@inflate:

; 1256 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1257 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  0164f	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  01652	8b c6		 mov	 eax, esi
  01654	2b 47 10	 sub	 eax, DWORD PTR [edi+16]
  01657	8b cf		 mov	 ecx, edi
  01659	50		 push	 eax
  0165a	e8 00 00 00 00	 call	 _updatewindow
  0165f	83 c4 04	 add	 esp, 4
  01662	85 c0		 test	 eax, eax
  01664	74 15		 je	 SHORT $LN503@inflate

; 1258 :             state->mode = MEM;

  01666	c7 43 04 52 3f
	00 00		 mov	 DWORD PTR [ebx+4], 16210 ; 00003f52H
$LN498@inflate:
  0166d	5f		 pop	 edi

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  0166e	5e		 pop	 esi
  0166f	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  01674	5b		 pop	 ebx
  01675	8b e5		 mov	 esp, ebp
  01677	5d		 pop	 ebp
  01678	c2 08 00	 ret	 8
$LN503@inflate:

; 1259 :             return Z_MEM_ERROR;
; 1260 :         }
; 1261 :     in -= strm->avail_in;

  0167b	8b 45 c8	 mov	 eax, DWORD PTR _in$1$[ebp]
  0167e	2b 47 04	 sub	 eax, DWORD PTR [edi+4]

; 1262 :     out -= strm->avail_out;

  01681	2b 77 10	 sub	 esi, DWORD PTR [edi+16]

; 1263 :     strm->total_in += in;

  01684	01 47 08	 add	 DWORD PTR [edi+8], eax

; 1264 :     strm->total_out += out;

  01687	01 77 14	 add	 DWORD PTR [edi+20], esi

; 1265 :     state->total += out;

  0168a	01 73 20	 add	 DWORD PTR [ebx+32], esi

; 1266 :     if ((state->wrap & 4) && out)

  0168d	f6 43 0c 04	 test	 BYTE PTR [ebx+12], 4
  01691	89 45 c8	 mov	 DWORD PTR _in$1$[ebp], eax
  01694	89 75 d8	 mov	 DWORD PTR _out$1$[ebp], esi
  01697	74 27		 je	 SHORT $LN504@inflate
  01699	85 f6		 test	 esi, esi
  0169b	74 23		 je	 SHORT $LN504@inflate

; 1267 :         strm->adler = state->check =

  0169d	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  016a0	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  016a3	2b c6		 sub	 eax, esi
  016a5	83 7b 14 00	 cmp	 DWORD PTR [ebx+20], 0
  016a9	56		 push	 esi
  016aa	50		 push	 eax
  016ab	51		 push	 ecx
  016ac	74 07		 je	 SHORT $LN515@inflate
  016ae	e8 00 00 00 00	 call	 _crc32@12
  016b3	eb 05		 jmp	 SHORT $LN516@inflate
$LN515@inflate:
  016b5	e8 00 00 00 00	 call	 _adler32@12
$LN516@inflate:
  016ba	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  016bd	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN504@inflate:

; 1268 :             UPDATE(state->check, strm->next_out - out, out);
; 1269 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  016c0	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  016c3	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  016c9	74 0c		 je	 SHORT $LN517@inflate
  016cb	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  016d1	74 04		 je	 SHORT $LN517@inflate
  016d3	33 f6		 xor	 esi, esi
  016d5	eb 05		 jmp	 SHORT $LN518@inflate
$LN517@inflate:
  016d7	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN518@inflate:
  016dc	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  016df	f7 d9		 neg	 ecx
  016e1	c7 45 08 80 00
	00 00		 mov	 DWORD PTR tv5482[ebp], 128 ; 00000080H
  016e8	1b c9		 sbb	 ecx, ecx
  016ea	33 c0		 xor	 eax, eax
  016ec	83 e1 40	 and	 ecx, 64			; 00000040H
  016ef	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  016f5	0f 44 45 08	 cmove	 eax, DWORD PTR tv5482[ebp]
  016f9	03 c8		 add	 ecx, eax
  016fb	03 4b 40	 add	 ecx, DWORD PTR [ebx+64]
  016fe	03 ce		 add	 ecx, esi

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01700	83 7d c8 00	 cmp	 DWORD PTR _in$1$[ebp], 0
  01704	89 4f 2c	 mov	 DWORD PTR [edi+44], ecx
  01707	75 06		 jne	 SHORT $LN507@inflate
  01709	83 7d d8 00	 cmp	 DWORD PTR _out$1$[ebp], 0
  0170d	74 06		 je	 SHORT $LN506@inflate
$LN507@inflate:
  0170f	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  01713	75 16		 jne	 SHORT $LN940@inflate
$LN506@inflate:
  01715	8b 45 d0	 mov	 eax, DWORD PTR _ret$1$[ebp]
  01718	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  0171d	5f		 pop	 edi
  0171e	85 c0		 test	 eax, eax

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  01720	5e		 pop	 esi
  01721	0f 44 c1	 cmove	 eax, ecx
  01724	5b		 pop	 ebx
  01725	8b e5		 mov	 esp, ebp
  01727	5d		 pop	 ebp
  01728	c2 08 00	 ret	 8
$LN940@inflate:

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  0172b	8b 45 d0	 mov	 eax, DWORD PTR _ret$1$[ebp]
  0172e	5f		 pop	 edi

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  0172f	5e		 pop	 esi
  01730	5b		 pop	 ebx
  01731	8b e5		 mov	 esp, ebp
  01733	5d		 pop	 ebp
  01734	c2 08 00	 ret	 8
  01737	90		 npad	 1
$LN979@inflate:
  01738	00 00 00 00	 DD	 $LN335@inflate
  0173c	00 00 00 00	 DD	 $LN32@inflate
  01740	00 00 00 00	 DD	 $LN46@inflate
  01744	00 00 00 00	 DD	 $LN60@inflate
  01748	00 00 00 00	 DD	 $LN361@inflate
  0174c	00 00 00 00	 DD	 $LN368@inflate
  01750	00 00 00 00	 DD	 $LN375@inflate
  01754	00 00 00 00	 DD	 $LN384@inflate
  01758	00 00 00 00	 DD	 $LN393@inflate
  0175c	00 00 00 00	 DD	 $LN105@inflate
  01760	00 00 00 00	 DD	 $LN400@inflate
  01764	00 00 00 00	 DD	 $LN402@inflate
  01768	00 00 00 00	 DD	 $LN403@inflate
  0176c	00 00 00 00	 DD	 $LN141@inflate
  01770	00 00 00 00	 DD	 $LN416@inflate
  01774	00 00 00 00	 DD	 $LN418@inflate
  01778	00 00 00 00	 DD	 $LN155@inflate
  0177c	00 00 00 00	 DD	 $LN532@inflate
  01780	00 00 00 00	 DD	 $LN535@inflate
  01784	00 00 00 00	 DD	 $LN448@inflate
  01788	00 00 00 00	 DD	 $LN450@inflate
  0178c	00 00 00 00	 DD	 $LN461@inflate
  01790	00 00 00 00	 DD	 $LN464@inflate
  01794	00 00 00 00	 DD	 $LN471@inflate
  01798	00 00 00 00	 DD	 $LN474@inflate
  0179c	00 00 00 00	 DD	 $LN485@inflate
  017a0	00 00 00 00	 DD	 $LN487@inflate
  017a4	00 00 00 00	 DD	 $LN492@inflate
  017a8	00 00 00 00	 DD	 $LN496@inflate
  017ac	00 00 00 00	 DD	 $LN497@inflate
  017b0	00 00 00 00	 DD	 $LN498@inflate
$LN980@inflate:
  017b4	00 00 00 00	 DD	 $LN408@inflate
  017b8	00 00 00 00	 DD	 $LN409@inflate
  017bc	00 00 00 00	 DD	 $LN411@inflate
  017c0	00 00 00 00	 DD	 $LN412@inflate
_inflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1280 :     struct inflate_state FAR *state;
; 1281 :     if (inflateStateCheck(strm))

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN2@inflateEnd

; 1282 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5e		 pop	 esi

; 1289 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@inflateEnd:

; 1283 :     state = (struct inflate_state FAR *)strm->state;

  0001c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]

; 1284 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0001f	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00022	85 c9		 test	 ecx, ecx
  00024	74 0f		 je	 SHORT $LN3@inflateEnd
  00026	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00029	51		 push	 ecx
  0002a	ff 76 28	 push	 DWORD PTR [esi+40]
  0002d	ff d0		 call	 eax
  0002f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00032	83 c4 08	 add	 esp, 8
$LN3@inflateEnd:

; 1285 :     ZFREE(strm, strm->state);

  00035	50		 push	 eax
  00036	ff 76 28	 push	 DWORD PTR [esi+40]
  00039	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0003c	ff d0		 call	 eax
  0003e	83 c4 08	 add	 esp, 8

; 1286 :     strm->state = Z_NULL;

  00041	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1287 :     Tracev((stderr, "inflate: end\n"));
; 1288 :     return Z_OK;

  00048	33 c0		 xor	 eax, eax
  0004a	5e		 pop	 esi

; 1289 : }

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateStateCheck
_TEXT	SEGMENT
_inflateStateCheck PROC					; COMDAT
; _strm$ = ecx

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	85 c9		 test	 ecx, ecx
  00002	74 27		 je	 SHORT $LN3@inflateSta
  00004	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00008	74 21		 je	 SHORT $LN3@inflateSta
  0000a	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0000e	74 1b		 je	 SHORT $LN3@inflateSta

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00010	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  00013	85 c0		 test	 eax, eax
  00015	74 14		 je	 SHORT $LN3@inflateSta
  00017	39 08		 cmp	 DWORD PTR [eax], ecx
  00019	75 10		 jne	 SHORT $LN3@inflateSta
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 03		 ja	 SHORT $LN3@inflateSta

; 115  :         return 1;
; 116  :     return 0;

  00028	33 c0		 xor	 eax, eax

; 117  : }

  0002a	c3		 ret	 0
$LN3@inflateSta:

; 111  :         return 1;

  0002b	b8 01 00 00 00	 mov	 eax, 1

; 117  : }

  00030	c3		 ret	 0
_inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 09		 je	 SHORT $LN2@inflateRes
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 142  : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  0001d	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00024	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
  0002b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 127  :     strm->msg = Z_NULL;

  00032	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00039	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003c	85 c0		 test	 eax, eax
  0003e	74 06		 je	 SHORT $LN3@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  00040	83 e0 01	 and	 eax, 1
  00043	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN3@inflateRes:

; 130  :     state->mode = HEAD;
; 131  :     state->last = 0;
; 132  :     state->havedict = 0;
; 133  :     state->dmax = 32768U;
; 134  :     state->head = Z_NULL;
; 135  :     state->hold = 0;
; 136  :     state->bits = 0;
; 137  :     state->lencode = state->distcode = state->next = state->codes;

  00046	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  0004c	c7 41 04 34 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16180 ; 00003f34H
  00053	89 41 70	 mov	 DWORD PTR [ecx+112], eax
  00056	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00059	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 138  :     state->sane = 1;
; 139  :     state->back = -1;
; 140  :     Tracev((stderr, "inflate: reset\n"));
; 141  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00065	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0006c	c7 41 18 00 80
	00 00		 mov	 DWORD PTR [ecx+24], 32768 ; 00008000H
  00073	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  0007a	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00081	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  00088	c7 81 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7108], 1
  00092	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 142  : }

  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_state$1$ = 8						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 161  :     int wrap;
; 162  :     struct inflate_state FAR *state;
; 163  : 
; 164  :     /* get the state */
; 165  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	8b cb		 mov	 ecx, ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 _inflateStateCheck
  00010	85 c0		 test	 eax, eax
  00012	75 66		 jne	 SHORT $LN7@inflateRes

; 166  :     state = (struct inflate_state FAR *)strm->state;
; 167  : 
; 168  :     /* extract wrap request from windowBits parameter */
; 169  :     if (windowBits < 0) {

  00014	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  00017	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0001a	89 45 08	 mov	 DWORD PTR _state$1$[ebp], eax
  0001d	85 f6		 test	 esi, esi
  0001f	79 06		 jns	 SHORT $LN3@inflateRes

; 170  :         wrap = 0;

  00021	33 ff		 xor	 edi, edi

; 171  :         windowBits = -windowBits;

  00023	f7 de		 neg	 esi

; 172  :     }

  00025	eb 10		 jmp	 SHORT $LN5@inflateRes
$LN3@inflateRes:

; 173  :     else {
; 174  :         wrap = (windowBits >> 4) + 5;

  00027	8b fe		 mov	 edi, esi
  00029	c1 ff 04	 sar	 edi, 4
  0002c	83 c7 05	 add	 edi, 5

; 175  : #ifdef GUNZIP
; 176  :         if (windowBits < 48)

  0002f	83 fe 30	 cmp	 esi, 48			; 00000030H
  00032	7d 03		 jge	 SHORT $LN5@inflateRes

; 177  :             windowBits &= 15;

  00034	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN5@inflateRes:

; 178  : #endif
; 179  :     }
; 180  : 
; 181  :     /* set number of window bits, free window if different */
; 182  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00037	85 f6		 test	 esi, esi
  00039	74 0a		 je	 SHORT $LN6@inflateRes
  0003b	83 fe 08	 cmp	 esi, 8
  0003e	7c 3a		 jl	 SHORT $LN7@inflateRes
  00040	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00043	7f 35		 jg	 SHORT $LN7@inflateRes
$LN6@inflateRes:

; 183  :         return Z_STREAM_ERROR;
; 184  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00045	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00048	85 c9		 test	 ecx, ecx
  0004a	74 1b		 je	 SHORT $LN8@inflateRes
  0004c	39 70 28	 cmp	 DWORD PTR [eax+40], esi
  0004f	74 16		 je	 SHORT $LN8@inflateRes

; 185  :         ZFREE(strm, state->window);

  00051	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00054	51		 push	 ecx
  00055	ff 73 28	 push	 DWORD PTR [ebx+40]
  00058	ff d0		 call	 eax

; 186  :         state->window = Z_NULL;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _state$1$[ebp]
  0005d	83 c4 08	 add	 esp, 8
  00060	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$LN8@inflateRes:

; 187  :     }
; 188  : 
; 189  :     /* update state and reset the rest of it */
; 190  :     state->wrap = wrap;
; 191  :     state->wbits = (unsigned)windowBits;
; 192  :     return inflateReset(strm);

  00067	53		 push	 ebx
  00068	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  0006b	89 70 28	 mov	 DWORD PTR [eax+40], esi
  0006e	e8 00 00 00 00	 call	 _inflateReset@4
  00073	5f		 pop	 edi

; 193  : }

  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
$LN7@inflateRes:
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00081	5b		 pop	 ebx
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 244  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_@16

; 245  : }

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 252  :     struct inflate_state FAR *state;
; 253  : 
; 254  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	75 43		 jne	 SHORT $LN5@inflatePri

; 255  :     state = (struct inflate_state FAR *)strm->state;

  00011	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 256  :     if (bits < 0) {

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00017	85 c9		 test	 ecx, ecx
  00019	79 0c		 jns	 SHORT $LN3@inflatePri

; 257  :         state->hold = 0;

  0001b	5f		 pop	 edi
  0001c	89 42 3c	 mov	 DWORD PTR [edx+60], eax

; 258  :         state->bits = 0;

  0001f	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 266  : }

  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflatePri:

; 259  :         return Z_OK;
; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00027	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0002a	7f 28		 jg	 SHORT $LN5@inflatePri
  0002c	8b 72 40	 mov	 esi, DWORD PTR [edx+64]
  0002f	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00032	83 ff 20	 cmp	 edi, 32			; 00000020H
  00035	77 1d		 ja	 SHORT $LN5@inflatePri

; 262  :     value &= (1L << bits) - 1;

  00037	b8 01 00 00 00	 mov	 eax, 1

; 263  :     state->hold += (unsigned)value << state->bits;
; 264  :     state->bits += (uInt)bits;

  0003c	89 7a 40	 mov	 DWORD PTR [edx+64], edi
  0003f	d3 e0		 shl	 eax, cl
  00041	8b ce		 mov	 ecx, esi
  00043	48		 dec	 eax
  00044	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  00047	d3 e0		 shl	 eax, cl
  00049	01 42 3c	 add	 DWORD PTR [edx+60], eax

; 265  :     return Z_OK;

  0004c	33 c0		 xor	 eax, eax
  0004e	5f		 pop	 edi

; 266  : }

  0004f	5e		 pop	 esi
  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflatePri:
  00054	5f		 pop	 edi

; 259  :         return Z_OK;
; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 266  : }

  0005a	5e		 pop	 esi
  0005b	5d		 pop	 ebp
  0005c	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 281  : #ifdef BUILDFIXED
; 282  :     static int virgin = 1;
; 283  :     static code *lenfix, *distfix;
; 284  :     static code fixed[544];
; 285  : 
; 286  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 287  :     if (virgin) {
; 288  :         unsigned sym, bits;
; 289  :         static code *next;
; 290  : 
; 291  :         /* literal/length table */
; 292  :         sym = 0;
; 293  :         while (sym < 144) state->lens[sym++] = 8;
; 294  :         while (sym < 256) state->lens[sym++] = 9;
; 295  :         while (sym < 280) state->lens[sym++] = 7;
; 296  :         while (sym < 288) state->lens[sym++] = 8;
; 297  :         next = fixed;
; 298  :         lenfix = next;
; 299  :         bits = 9;
; 300  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 301  : 
; 302  :         /* distance table */
; 303  :         sym = 0;
; 304  :         while (sym < 32) state->lens[sym++] = 5;
; 305  :         distfix = next;
; 306  :         bits = 5;
; 307  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 308  : 
; 309  :         /* do this just once */
; 310  :         virgin = 0;
; 311  :     }
; 312  : #else /* !BUILDFIXED */
; 313  : #   include "inffixed.h"
; 314  : #endif /* BUILDFIXED */
; 315  :     state->lencode = lenfix;

  00000	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 316  :     state->lenbits = 9;

  00007	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 317  :     state->distcode = distfix;

  0000e	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 318  :     state->distbits = 5;

  00015	c7 41 5c 05 00
	00 00		 mov	 DWORD PTR [ecx+92], 5

; 319  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
$T1 = -4						; size = 4
_copy$ = 8						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = ecx
; _end$ = edx

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b da		 mov	 ebx, edx
  00007	8b d1		 mov	 edx, ecx
  00009	56		 push	 esi

; 401  :     struct inflate_state FAR *state;
; 402  :     unsigned dist;
; 403  : 
; 404  :     state = (struct inflate_state FAR *)strm->state;

  0000a	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]

; 405  : 
; 406  :     /* if it hasn't been done already, allocate space for the window */
; 407  :     if (state->window == Z_NULL) {

  0000d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00010	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00013	85 c0		 test	 eax, eax
  00015	75 2d		 jne	 SHORT $LN15@updatewind

; 408  :         state->window = (unsigned char FAR *)

  00017	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0001a	b8 01 00 00 00	 mov	 eax, 1
  0001f	d3 e0		 shl	 eax, cl
  00021	6a 01		 push	 1
  00023	50		 push	 eax
  00024	ff 72 28	 push	 DWORD PTR [edx+40]
  00027	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002a	ff d0		 call	 eax
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00032	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));
; 411  :         if (state->window == Z_NULL) return 1;

  00035	85 c0		 test	 eax, eax
  00037	75 0b		 jne	 SHORT $LN15@updatewind
  00039	5e		 pop	 esi
  0003a	b8 01 00 00 00	 mov	 eax, 1

; 444  : }

  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN15@updatewind:
  00044	57		 push	 edi

; 412  :     }
; 413  : 
; 414  :     /* if window not in use yet, initialize */
; 415  :     if (state->wsize == 0) {

  00045	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  00048	85 ff		 test	 edi, edi
  0004a	75 1b		 jne	 SHORT $LN14@updatewind

; 416  :         state->wsize = 1U << state->wbits;

  0004c	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0004f	bf 01 00 00 00	 mov	 edi, 1
  00054	d3 e7		 shl	 edi, cl
  00056	89 7e 2c	 mov	 DWORD PTR [esi+44], edi

; 417  :         state->wnext = 0;

  00059	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0

; 418  :         state->whave = 0;

  00060	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN14@updatewind:

; 419  :     }
; 420  : 
; 421  :     /* copy state->wsize or less output bytes into the circular window */
; 422  :     if (copy >= state->wsize) {

  00067	8b 55 08	 mov	 edx, DWORD PTR _copy$[ebp]
  0006a	3b d7		 cmp	 edx, edi
  0006c	72 23		 jb	 SHORT $LN5@updatewind

; 423  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  0006e	57		 push	 edi
  0006f	2b df		 sub	 ebx, edi
  00071	53		 push	 ebx
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _memcpy

; 424  :         state->wnext = 0;
; 425  :         state->whave = state->wsize;

  00078	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 441  :         }
; 442  :     }
; 443  :     return 0;

  0007e	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00081	33 c0		 xor	 eax, eax
  00083	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi

; 444  : }

  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
$LN5@updatewind:

; 426  :     }
; 427  :     else {
; 428  :         dist = state->wsize - state->wnext;

  00091	2b 7e 34	 sub	 edi, DWORD PTR [esi+52]

; 429  :         if (dist > copy) dist = copy;
; 430  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  00094	8b c3		 mov	 eax, ebx
  00096	3b fa		 cmp	 edi, edx
  00098	0f 47 fa	 cmova	 edi, edx
  0009b	2b c2		 sub	 eax, edx
  0009d	57		 push	 edi
  0009e	50		 push	 eax
  0009f	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  000a2	03 46 34	 add	 eax, DWORD PTR [esi+52]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _memcpy

; 431  :         copy -= dist;

  000ab	8b 45 08	 mov	 eax, DWORD PTR _copy$[ebp]
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	2b c7		 sub	 eax, edi
  000b3	89 45 08	 mov	 DWORD PTR _copy$[ebp], eax

; 432  :         if (copy) {

  000b6	74 24		 je	 SHORT $LN8@updatewind

; 433  :             zmemcpy(state->window, end - copy, copy);

  000b8	50		 push	 eax
  000b9	2b d8		 sub	 ebx, eax
  000bb	53		 push	 ebx
  000bc	ff 76 38	 push	 DWORD PTR [esi+56]
  000bf	e8 00 00 00 00	 call	 _memcpy

; 434  :             state->wnext = copy;
; 435  :             state->whave = state->wsize;

  000c4	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ca	8b 55 08	 mov	 edx, DWORD PTR _copy$[ebp]

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000cd	89 46 30	 mov	 DWORD PTR [esi+48], eax
  000d0	33 c0		 xor	 eax, eax
  000d2	89 56 34	 mov	 DWORD PTR [esi+52], edx
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi

; 444  : }

  000d7	5b		 pop	 ebx
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
$LN8@updatewind:

; 436  :         }
; 437  :         else {
; 438  :             state->wnext += dist;

  000dc	01 7e 34	 add	 DWORD PTR [esi+52], edi

; 439  :             if (state->wnext == state->wsize) state->wnext = 0;

  000df	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  000e2	39 4e 34	 cmp	 DWORD PTR [esi+52], ecx
  000e5	75 07		 jne	 SHORT $LN10@updatewind
  000e7	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
$LN10@updatewind:

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  000ee	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000f1	3b c1		 cmp	 eax, ecx
  000f3	73 05		 jae	 SHORT $LN11@updatewind
  000f5	03 c7		 add	 eax, edi

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000f7	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN11@updatewind:
  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	33 c0		 xor	 eax, eax

; 444  : }

  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1296 :     struct inflate_state FAR *state;
; 1297 : 
; 1298 :     /* check state */
; 1299 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateGet
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1312 : }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
$LN2@inflateGet:
  00018	56		 push	 esi

; 1300 :     state = (struct inflate_state FAR *)strm->state;

  00019	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]

; 1301 : 
; 1302 :     /* copy dictionary */
; 1303 :     if (state->whave && dictionary != Z_NULL) {

  0001c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0001f	85 c0		 test	 eax, eax
  00021	74 2f		 je	 SHORT $LN3@inflateGet
  00023	57		 push	 edi
  00024	8b 7d 0c	 mov	 edi, DWORD PTR _dictionary$[ebp]
  00027	85 ff		 test	 edi, edi
  00029	74 26		 je	 SHORT $LN6@inflateGet

; 1304 :         zmemcpy(dictionary, state->window + state->wnext,

  0002b	2b 46 34	 sub	 eax, DWORD PTR [esi+52]
  0002e	50		 push	 eax
  0002f	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00032	03 46 34	 add	 eax, DWORD PTR [esi+52]
  00035	50		 push	 eax
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 _memcpy

; 1305 :                 state->whave - state->wnext);
; 1306 :         zmemcpy(dictionary + state->whave - state->wnext,

  0003c	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0003f	2b f8		 sub	 edi, eax
  00041	03 7e 30	 add	 edi, DWORD PTR [esi+48]
  00044	50		 push	 eax
  00045	ff 76 38	 push	 DWORD PTR [esi+56]
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 _memcpy
  0004e	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@inflateGet:
  00051	5f		 pop	 edi
$LN3@inflateGet:

; 1307 :                 state->window, state->wnext);
; 1308 :     }
; 1309 :     if (dictLength != Z_NULL)

  00052	8b 4d 10	 mov	 ecx, DWORD PTR _dictLength$[ebp]
  00055	85 c9		 test	 ecx, ecx
  00057	74 05		 je	 SHORT $LN4@inflateGet

; 1310 :         *dictLength = state->whave;

  00059	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0005c	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@inflateGet:

; 1311 :     return Z_OK;

  0005e	33 c0		 xor	 eax, eax
  00060	5e		 pop	 esi

; 1312 : }

  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1318 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1319 :     struct inflate_state FAR *state;
; 1320 :     unsigned long dictid;
; 1321 :     int ret;
; 1322 : 
; 1323 :     /* check state */
; 1324 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00008	8b cf		 mov	 ecx, edi
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	75 7c		 jne	 SHORT $LN10@inflateSet

; 1325 :     state = (struct inflate_state FAR *)strm->state;

  00013	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]

; 1326 :     if (state->wrap != 0 && state->mode != DICT)

  00016	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00019	74 09		 je	 SHORT $LN9@inflateSet
  0001b	81 7e 04 3e 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16190 ; 00003f3eH
  00022	75 6b		 jne	 SHORT $LN10@inflateSet
$LN9@inflateSet:

; 1328 : 
; 1329 :     /* check for correct dictionary identifier */
; 1330 :     if (state->mode == DICT) {

  00024	81 7e 04 3e 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16190 ; 00003f3eH
  0002b	53		 push	 ebx
  0002c	8b 5d 10	 mov	 ebx, DWORD PTR _dictLength$[ebp]
  0002f	75 26		 jne	 SHORT $LN5@inflateSet

; 1331 :         dictid = adler32(0L, Z_NULL, 0);

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	6a 00		 push	 0
  00037	e8 00 00 00 00	 call	 _adler32@12

; 1332 :         dictid = adler32(dictid, dictionary, dictLength);

  0003c	53		 push	 ebx
  0003d	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _adler32@12

; 1333 :         if (dictid != state->check)

  00046	3b 46 1c	 cmp	 eax, DWORD PTR [esi+28]
  00049	74 0c		 je	 SHORT $LN5@inflateSet

; 1334 :             return Z_DATA_ERROR;

  0004b	5b		 pop	 ebx
  0004c	5f		 pop	 edi
  0004d	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1347 : }

  00052	5e		 pop	 esi
  00053	5d		 pop	 ebp
  00054	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflateSet:

; 1335 :     }
; 1336 : 
; 1337 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1338 :        existing dictionary if appropriate */
; 1339 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  00057	8b 55 0c	 mov	 edx, DWORD PTR _dictionary$[ebp]
  0005a	8b cf		 mov	 ecx, edi
  0005c	53		 push	 ebx
  0005d	8d 14 1a	 lea	 edx, DWORD PTR [edx+ebx]
  00060	e8 00 00 00 00	 call	 _updatewindow
  00065	83 c4 04	 add	 esp, 4

; 1340 :     if (ret) {

  00068	85 c0		 test	 eax, eax
  0006a	74 13		 je	 SHORT $LN6@inflateSet

; 1341 :         state->mode = MEM;

  0006c	5b		 pop	 ebx
  0006d	5f		 pop	 edi
  0006e	c7 46 04 52 3f
	00 00		 mov	 DWORD PTR [esi+4], 16210 ; 00003f52H

; 1342 :         return Z_MEM_ERROR;

  00075	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH

; 1347 : }

  0007a	5e		 pop	 esi
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN6@inflateSet:
  0007f	5b		 pop	 ebx
  00080	5f		 pop	 edi

; 1343 :     }
; 1344 :     state->havedict = 1;

  00081	c7 46 10 01 00
	00 00		 mov	 DWORD PTR [esi+16], 1

; 1345 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1346 :     return Z_OK;

  00088	33 c0		 xor	 eax, eax

; 1347 : }

  0008a	5e		 pop	 esi
  0008b	5d		 pop	 ebp
  0008c	c2 0c 00	 ret	 12			; 0000000cH
$LN10@inflateSet:
  0008f	5f		 pop	 edi

; 1327 :         return Z_STREAM_ERROR;

  00090	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1347 : }

  00095	5e		 pop	 esi
  00096	5d		 pop	 ebp
  00097	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1352 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1353 :     struct inflate_state FAR *state;
; 1354 : 
; 1355 :     /* check state */
; 1356 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	75 1c		 jne	 SHORT $LN5@inflateGet

; 1357 :     state = (struct inflate_state FAR *)strm->state;

  0000f	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00012	f6 41 0c 02	 test	 BYTE PTR [ecx+12], 2
  00016	74 13		 je	 SHORT $LN5@inflateGet

; 1359 : 
; 1360 :     /* save header structure */
; 1361 :     state->head = head;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0001b	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 1362 :     head->done = 0;

  0001e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1363 :     return Z_OK;

  00025	33 c0		 xor	 eax, eax

; 1364 : }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
$LN5@inflateGet:

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1364 : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
_len$ = 8						; size = 4
_syncsearch PROC					; COMDAT
; _have$ = ecx
; _buf$ = edx

; 1381 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1382 :     unsigned got;
; 1383 :     unsigned next;
; 1384 : 
; 1385 :     got = *have;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1386 :     next = 0;
; 1387 :     while (next < len && got < 4) {

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00012	89 4d fc	 mov	 DWORD PTR _have$1$[ebp], ecx
  00015	85 ff		 test	 edi, edi
  00017	74 50		 je	 SHORT $LN13@syncsearch
  00019	53		 push	 ebx
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL2@syncsearch:
  00020	83 f8 04	 cmp	 eax, 4
  00023	73 36		 jae	 SHORT $LN14@syncsearch

; 1388 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00025	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  00028	83 f8 02	 cmp	 eax, 2
  0002b	0f b6 cb	 movzx	 ecx, bl
  0002e	1b d2		 sbb	 edx, edx
  00030	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00036	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003c	3b ca		 cmp	 ecx, edx
  0003e	75 03		 jne	 SHORT $LN4@syncsearch

; 1389 :             got++;

  00040	40		 inc	 eax
  00041	eb 10		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1390 :         else if (buf[next])
; 1391 :             got = 0;
; 1392 :         else
; 1393 :             got = 4 - got;

  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	33 d2		 xor	 edx, edx
  0004a	2b c8		 sub	 ecx, eax
  0004c	84 db		 test	 bl, bl
  0004e	8b c1		 mov	 eax, ecx
  00050	0f 45 c2	 cmovne	 eax, edx
$LN7@syncsearch:

; 1394 :         next++;

  00053	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00056	46		 inc	 esi
  00057	3b f7		 cmp	 esi, edi
  00059	72 c5		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1395 :     }
; 1396 :     *have = got;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _have$1$[ebp]
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi
  00060	89 01		 mov	 DWORD PTR [ecx], eax

; 1397 :     return next;

  00062	8b c6		 mov	 eax, esi

; 1398 : }

  00064	5e		 pop	 esi
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN13@syncsearch:

; 1395 :     }
; 1396 :     *have = got;

  00069	89 01		 mov	 DWORD PTR [ecx], eax

; 1397 :     return next;

  0006b	8b c6		 mov	 eax, esi
  0006d	5f		 pop	 edi

; 1398 : }

  0006e	5e		 pop	 esi
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
tv385 = 8						; size = 4
_buf$ = 8						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1403 :     unsigned len;               /* number of bytes to look at or looked at */
; 1404 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1405 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1406 :     struct inflate_state FAR *state;
; 1407 : 
; 1408 :     /* check parameters */
; 1409 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	8b cb		 mov	 ecx, ebx
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN4@inflateSyn
  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5b		 pop	 ebx

; 1441 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1410 :     state = (struct inflate_state FAR *)strm->state;
; 1411 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001f	57		 push	 edi
  00020	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00023	85 c0		 test	 eax, eax
  00025	75 11		 jne	 SHORT $LN15@inflateSyn
  00027	83 7f 40 08	 cmp	 DWORD PTR [edi+64], 8
  0002b	73 0b		 jae	 SHORT $LN15@inflateSyn
  0002d	5f		 pop	 edi
  0002e	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00033	5b		 pop	 ebx

; 1441 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN15@inflateSyn:

; 1412 : 
; 1413 :     /* if first time, start search in bit buffer */
; 1414 :     if (state->mode != SYNC) {

  00038	81 7f 04 53 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16211 ; 00003f53H
  0003f	56		 push	 esi
  00040	74 58		 je	 SHORT $LN13@inflateSyn

; 1415 :         state->mode = SYNC;
; 1416 :         state->hold <<= state->bits & 7;

  00042	8b 57 40	 mov	 edx, DWORD PTR [edi+64]
  00045	8b ca		 mov	 ecx, edx
  00047	8b 77 3c	 mov	 esi, DWORD PTR [edi+60]
  0004a	83 e1 07	 and	 ecx, 7
  0004d	d3 e6		 shl	 esi, cl

; 1417 :         state->bits -= state->bits & 7;

  0004f	2b d1		 sub	 edx, ecx

; 1418 :         len = 0;

  00051	33 c9		 xor	 ecx, ecx
  00053	c7 47 04 53 3f
	00 00		 mov	 DWORD PTR [edi+4], 16211 ; 00003f53H
  0005a	89 77 3c	 mov	 DWORD PTR [edi+60], esi
  0005d	89 57 40	 mov	 DWORD PTR [edi+64], edx

; 1419 :         while (state->bits >= 8) {

  00060	83 fa 08	 cmp	 edx, 8
  00063	72 19		 jb	 SHORT $LN3@inflateSyn
$LL2@inflateSyn:

; 1420 :             buf[len++] = (unsigned char)(state->hold);

  00065	8a 47 3c	 mov	 al, BYTE PTR [edi+60]

; 1421 :             state->hold >>= 8;
; 1422 :             state->bits -= 8;

  00068	83 ea 08	 sub	 edx, 8
  0006b	88 44 0d 08	 mov	 BYTE PTR _buf$[ebp+ecx], al
  0006f	41		 inc	 ecx
  00070	c1 ee 08	 shr	 esi, 8
  00073	89 77 3c	 mov	 DWORD PTR [edi+60], esi
  00076	83 fa 08	 cmp	 edx, 8
  00079	73 ea		 jae	 SHORT $LL2@inflateSyn
  0007b	89 57 40	 mov	 DWORD PTR [edi+64], edx
$LN3@inflateSyn:

; 1423 :         }
; 1424 :         state->have = 0;

  0007e	8d 77 6c	 lea	 esi, DWORD PTR [edi+108]

; 1425 :         syncsearch(&(state->have), buf, len);

  00081	8d 55 08	 lea	 edx, DWORD PTR _buf$[ebp]
  00084	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0008a	51		 push	 ecx
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 _syncsearch
  00092	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00095	83 c4 04	 add	 esp, 4
  00098	eb 03		 jmp	 SHORT $LN6@inflateSyn
$LN13@inflateSyn:
  0009a	8d 77 6c	 lea	 esi, DWORD PTR [edi+108]
$LN6@inflateSyn:

; 1426 :     }
; 1427 : 
; 1428 :     /* search available input */
; 1429 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  0009d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0009f	8b ce		 mov	 ecx, esi
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _syncsearch

; 1430 :     strm->avail_in -= len;

  000a7	29 43 04	 sub	 DWORD PTR [ebx+4], eax
  000aa	83 c4 04	 add	 esp, 4

; 1431 :     strm->next_in += len;

  000ad	01 03		 add	 DWORD PTR [ebx], eax

; 1432 :     strm->total_in += len;

  000af	03 43 08	 add	 eax, DWORD PTR [ebx+8]
  000b2	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1433 : 
; 1434 :     /* return no joy or set up to restart inflate() on a new block */
; 1435 :     if (state->have != 4) return Z_DATA_ERROR;

  000b5	83 3e 04	 cmp	 DWORD PTR [esi], 4
  000b8	89 45 08	 mov	 DWORD PTR tv385[ebp], eax
  000bb	74 0c		 je	 SHORT $LN7@inflateSyn
  000bd	5e		 pop	 esi
  000be	5f		 pop	 edi
  000bf	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000c4	5b		 pop	 ebx

; 1441 : }

  000c5	5d		 pop	 ebp
  000c6	c2 04 00	 ret	 4
$LN7@inflateSyn:

; 1436 :     in = strm->total_in;  out = strm->total_out;

  000c9	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 1437 :     inflateReset(strm);

  000cc	53		 push	 ebx
  000cd	e8 00 00 00 00	 call	 _inflateReset@4

; 1438 :     strm->total_in = in;  strm->total_out = out;

  000d2	8b 45 08	 mov	 eax, DWORD PTR tv385[ebp]
  000d5	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000d8	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1439 :     state->mode = TYPE;
; 1440 :     return Z_OK;

  000db	33 c0		 xor	 eax, eax
  000dd	5e		 pop	 esi
  000de	c7 47 04 3f 3f
	00 00		 mov	 DWORD PTR [edi+4], 16191 ; 00003f3fH
  000e5	5f		 pop	 edi
  000e6	5b		 pop	 ebx

; 1441 : }

  000e7	5d		 pop	 ebp
  000e8	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1454 :     struct inflate_state FAR *state;
; 1455 : 
; 1456 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateSyn
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1459 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateSyn:

; 1457 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1458 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 04 41 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16193 ; 00003f41H
  00022	75 0f		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00028	75 09		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1459 : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1458 :     return state->mode == STORED && state->bits == 0;

  00033	33 c0		 xor	 eax, eax

; 1459 : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_window$1$ = 12						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1464 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1465 :     struct inflate_state FAR *state;
; 1466 :     struct inflate_state FAR *copy;
; 1467 :     unsigned char FAR *window;
; 1468 :     unsigned wsize;
; 1469 : 
; 1470 :     /* check input */
; 1471 :     if (inflateStateCheck(source) || dest == Z_NULL)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _source$[ebp]
  00007	8b cf		 mov	 ecx, edi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 2e 01 00
	00		 jne	 $LN3@inflateCop
  00016	39 45 08	 cmp	 DWORD PTR _dest$[ebp], eax
  00019	0f 84 25 01 00
	00		 je	 $LN3@inflateCop

; 1473 :     state = (struct inflate_state FAR *)source->state;
; 1474 : 
; 1475 :     /* allocate space */
; 1476 :     copy = (struct inflate_state FAR *)

  0001f	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00022	53		 push	 ebx
  00023	8b 5f 1c	 mov	 ebx, DWORD PTR [edi+28]
  00026	56		 push	 esi
  00027	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0002c	6a 01		 push	 1
  0002e	ff 77 28	 push	 DWORD PTR [edi+40]
  00031	ff d0		 call	 eax
  00033	8b f0		 mov	 esi, eax
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1477 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1478 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00038	85 f6		 test	 esi, esi
  0003a	74 38		 je	 SHORT $LN14@inflateCop

; 1479 :     window = Z_NULL;
; 1480 :     if (state->window != Z_NULL) {

  0003c	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00040	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  00047	74 37		 je	 SHORT $LN11@inflateCop

; 1481 :         window = (unsigned char FAR *)

  00049	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	d3 e0		 shl	 eax, cl
  00053	6a 01		 push	 1
  00055	50		 push	 eax
  00056	ff 77 28	 push	 DWORD PTR [edi+40]
  00059	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0005c	ff d0		 call	 eax
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	89 45 0c	 mov	 DWORD PTR _window$1$[ebp], eax

; 1482 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1483 :         if (window == Z_NULL) {

  00064	85 c0		 test	 eax, eax
  00066	75 18		 jne	 SHORT $LN11@inflateCop

; 1484 :             ZFREE(source, copy);

  00068	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0006b	56		 push	 esi
  0006c	ff 77 28	 push	 DWORD PTR [edi+40]
  0006f	ff d0		 call	 eax
  00071	83 c4 08	 add	 esp, 8
$LN14@inflateCop:

; 1485 :             return Z_MEM_ERROR;

  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0007b	5f		 pop	 edi

; 1506 : }

  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
$LN11@inflateCop:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     /* copy state */
; 1490 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00080	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00083	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 1491 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  00086	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0008b	53		 push	 ebx
  0008c	56		 push	 esi
  0008d	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00090	0f 10 47 10	 movups	 xmm0, XMMWORD PTR [edi+16]
  00094	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  00098	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [edi+32]
  0009c	0f 11 40 20	 movups	 XMMWORD PTR [eax+32], xmm0
  000a0	f3 0f 7e 47 30	 movq	 xmm0, QWORD PTR [edi+48]
  000a5	66 0f d6 40 30	 movq	 QWORD PTR [eax+48], xmm0
  000aa	e8 00 00 00 00	 call	 _memcpy

; 1492 :     copy->strm = dest;

  000af	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]

; 1493 :     if (state->lencode >= state->codes &&

  000b2	8d 83 34 05 00
	00		 lea	 eax, DWORD PTR [ebx+1332]
  000b8	89 3e		 mov	 DWORD PTR [esi], edi
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bd	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  000c0	3b c8		 cmp	 ecx, eax
  000c2	72 38		 jb	 SHORT $LN7@inflateCop
  000c4	8d 83 c0 1b 00
	00		 lea	 eax, DWORD PTR [ebx+7104]
  000ca	3b c8		 cmp	 ecx, eax
  000cc	77 2e		 ja	 SHORT $LN7@inflateCop

; 1494 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1495 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000ce	2b cb		 sub	 ecx, ebx
  000d0	8d 81 cc fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1332]
  000d6	c1 f8 02	 sar	 eax, 2
  000d9	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000de	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000e1	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 1496 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000e4	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  000e7	2b c3		 sub	 eax, ebx
  000e9	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  000ee	c1 f8 02	 sar	 eax, 2
  000f1	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000f6	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000f9	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN7@inflateCop:

; 1497 :     }
; 1498 :     copy->next = copy->codes + (state->next - state->codes);

  000fc	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]
  000ff	2b c3		 sub	 eax, ebx
  00101	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00106	c1 f8 02	 sar	 eax, 2
  00109	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  0010e	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00111	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 1499 :     if (window != Z_NULL) {

  00114	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  00117	85 c0		 test	 eax, eax
  00119	74 1a		 je	 SHORT $LN8@inflateCop

; 1500 :         wsize = 1U << state->wbits;

  0011b	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  0011e	ba 01 00 00 00	 mov	 edx, 1
  00123	d3 e2		 shl	 edx, cl

; 1501 :         zmemcpy(window, state->window, wsize);

  00125	52		 push	 edx
  00126	ff 73 38	 push	 DWORD PTR [ebx+56]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _memcpy
  0012f	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@inflateCop:

; 1502 :     }
; 1503 :     copy->window = window;

  00135	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 1504 :     dest->state = (struct internal_state FAR *)copy;
; 1505 :     return Z_OK;

  00138	33 c0		 xor	 eax, eax
  0013a	89 77 1c	 mov	 DWORD PTR [edi+28], esi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx
  0013f	5f		 pop	 edi

; 1506 : }

  00140	5d		 pop	 ebp
  00141	c2 08 00	 ret	 8
$LN3@inflateCop:

; 1472 :         return Z_STREAM_ERROR;

  00144	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00149	5f		 pop	 edi

; 1506 : }

  0014a	5d		 pop	 ebp
  0014b	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1512 :     struct inflate_state FAR *state;
; 1513 : 
; 1514 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateUnd
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1523 : #endif
; 1524 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateUnd:

; 1515 :     state = (struct inflate_state FAR *)strm->state;
; 1516 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1517 :     state->sane = !subvert;
; 1518 :     return Z_OK;
; 1519 : #else
; 1520 :     (void)subvert;
; 1521 :     state->sane = 1;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001b	c7 80 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7108], 1

; 1522 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1523 : #endif
; 1524 : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateValidate@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_check$ = 12						; size = 4
_inflateValidate@8 PROC					; COMDAT

; 1529 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1530 :     struct inflate_state FAR *state;
; 1531 : 
; 1532 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateVal
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1539 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateVal:

; 1533 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0001b	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]

; 1534 :     if (check)
; 1535 :         state->wrap |= 4;
; 1536 :     else
; 1537 :         state->wrap &= ~4;
; 1538 :     return Z_OK;

  0001e	8b c1		 mov	 eax, ecx
  00020	83 e0 fb	 and	 eax, -5			; fffffffbH
  00023	83 c9 04	 or	 ecx, 4
  00026	83 7d 0c 00	 cmp	 DWORD PTR _check$[ebp], 0
  0002a	0f 44 c8	 cmove	 ecx, eax
  0002d	33 c0		 xor	 eax, eax
  0002f	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1539 : }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
_inflateValidate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1544 :     struct inflate_state FAR *state;
; 1545 : 
; 1546 :     if (inflateStateCheck(strm))

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateMar

; 1547 :         return -(1L << 16);

  0000f	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateMar:

; 1548 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 12		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00029	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0002f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00032	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN6@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00038	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003e	75 18		 jne	 SHORT $LN4@inflateMar
  00040	8b 88 cc 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7116]
  00046	2b 48 44	 sub	 ecx, DWORD PTR [eax+68]
  00049	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0004f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00052	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN4@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00058	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0005e	33 c9		 xor	 ecx, ecx
  00060	c1 e0 10	 shl	 eax, 16			; 00000010H
  00063	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\prj\visiator_windows\v26\zlib\inflate.c
;	COMDAT _inflateCodesUsed@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateCodesUsed@4 PROC				; COMDAT

; 1556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1557 :     struct inflate_state FAR *state;
; 1558 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateCod
  0000f	83 c8 ff	 or	 eax, -1

; 1561 : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN2@inflateCod:

; 1559 :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1560 :     return (unsigned long)(state->next - state->codes);

  00019	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  0001c	2b c1		 sub	 eax, ecx
  0001e	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00023	c1 f8 02	 sar	 eax, 2

; 1561 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
_inflateCodesUsed@4 ENDP
_TEXT	ENDS
END
